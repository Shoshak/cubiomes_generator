/* automatically generated by rust-bindgen 0.69.4 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
pub const __STDC_FORMAT_MACROS: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC2X: u32 = 0;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __TIMESIZE: u32 = 64;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const __GLIBC_USE_C2X_STRTOL: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_60559_BFP__: u32 = 201404;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_IEC_60559_COMPLEX__: u32 = 201404;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 39;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _STDLIB_H: u32 = 1;
pub const WNOHANG: u32 = 1;
pub const WUNTRACED: u32 = 2;
pub const WSTOPPED: u32 = 2;
pub const WEXITED: u32 = 4;
pub const WCONTINUED: u32 = 8;
pub const WNOWAIT: u32 = 16777216;
pub const __WNOTHREAD: u32 = 536870912;
pub const __WALL: u32 = 1073741824;
pub const __WCLONE: u32 = 2147483648;
pub const __W_CONTINUED: u32 = 65535;
pub const __WCOREFLAG: u32 = 128;
pub const __HAVE_FLOAT128: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128: u32 = 0;
pub const __HAVE_FLOAT64X: u32 = 1;
pub const __HAVE_FLOAT64X_LONG_DOUBLE: u32 = 1;
pub const __HAVE_FLOAT16: u32 = 0;
pub const __HAVE_FLOAT32: u32 = 1;
pub const __HAVE_FLOAT64: u32 = 1;
pub const __HAVE_FLOAT32X: u32 = 1;
pub const __HAVE_FLOAT128X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT16: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128X: u32 = 0;
pub const __HAVE_FLOATN_NOT_TYPEDEF: u32 = 0;
pub const __ldiv_t_defined: u32 = 1;
pub const __lldiv_t_defined: u32 = 1;
pub const RAND_MAX: u32 = 2147483647;
pub const EXIT_FAILURE: u32 = 1;
pub const EXIT_SUCCESS: u32 = 0;
pub const _SYS_TYPES_H: u32 = 1;
pub const _BITS_TYPES_H: u32 = 1;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const __clock_t_defined: u32 = 1;
pub const __clockid_t_defined: u32 = 1;
pub const __time_t_defined: u32 = 1;
pub const __timer_t_defined: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const __BIT_TYPES_DEFINED__: u32 = 1;
pub const _ENDIAN_H: u32 = 1;
pub const _BITS_ENDIAN_H: u32 = 1;
pub const __LITTLE_ENDIAN: u32 = 1234;
pub const __BIG_ENDIAN: u32 = 4321;
pub const __PDP_ENDIAN: u32 = 3412;
pub const _BITS_ENDIANNESS_H: u32 = 1;
pub const __BYTE_ORDER: u32 = 1234;
pub const __FLOAT_WORD_ORDER: u32 = 1234;
pub const LITTLE_ENDIAN: u32 = 1234;
pub const BIG_ENDIAN: u32 = 4321;
pub const PDP_ENDIAN: u32 = 3412;
pub const BYTE_ORDER: u32 = 1234;
pub const _BITS_BYTESWAP_H: u32 = 1;
pub const _BITS_UINTN_IDENTITY_H: u32 = 1;
pub const _SYS_SELECT_H: u32 = 1;
pub const __sigset_t_defined: u32 = 1;
pub const __timeval_defined: u32 = 1;
pub const _STRUCT_TIMESPEC: u32 = 1;
pub const FD_SETSIZE: u32 = 1024;
pub const _BITS_PTHREADTYPES_COMMON_H: u32 = 1;
pub const _THREAD_SHARED_TYPES_H: u32 = 1;
pub const _BITS_PTHREADTYPES_ARCH_H: u32 = 1;
pub const __SIZEOF_PTHREAD_MUTEX_T: u32 = 40;
pub const __SIZEOF_PTHREAD_ATTR_T: u32 = 56;
pub const __SIZEOF_PTHREAD_RWLOCK_T: u32 = 56;
pub const __SIZEOF_PTHREAD_BARRIER_T: u32 = 32;
pub const __SIZEOF_PTHREAD_MUTEXATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_COND_T: u32 = 48;
pub const __SIZEOF_PTHREAD_CONDATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_RWLOCKATTR_T: u32 = 8;
pub const __SIZEOF_PTHREAD_BARRIERATTR_T: u32 = 4;
pub const _THREAD_MUTEX_INTERNAL_H: u32 = 1;
pub const __PTHREAD_MUTEX_HAVE_PREV: u32 = 1;
pub const __have_pthread_attr_t: u32 = 1;
pub const _ALLOCA_H: u32 = 1;
pub const _INTTYPES_H: u32 = 1;
pub const _STDINT_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const _BITS_STDINT_LEAST_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const ____gwchar_t_defined: u32 = 1;
pub const __PRI64_PREFIX: &[u8; 2] = b"l\0";
pub const __PRIPTR_PREFIX: &[u8; 2] = b"l\0";
pub const PRId8: &[u8; 2] = b"d\0";
pub const PRId16: &[u8; 2] = b"d\0";
pub const PRId32: &[u8; 2] = b"d\0";
pub const PRId64: &[u8; 3] = b"ld\0";
pub const PRIdLEAST8: &[u8; 2] = b"d\0";
pub const PRIdLEAST16: &[u8; 2] = b"d\0";
pub const PRIdLEAST32: &[u8; 2] = b"d\0";
pub const PRIdLEAST64: &[u8; 3] = b"ld\0";
pub const PRIdFAST8: &[u8; 2] = b"d\0";
pub const PRIdFAST16: &[u8; 3] = b"ld\0";
pub const PRIdFAST32: &[u8; 3] = b"ld\0";
pub const PRIdFAST64: &[u8; 3] = b"ld\0";
pub const PRIi8: &[u8; 2] = b"i\0";
pub const PRIi16: &[u8; 2] = b"i\0";
pub const PRIi32: &[u8; 2] = b"i\0";
pub const PRIi64: &[u8; 3] = b"li\0";
pub const PRIiLEAST8: &[u8; 2] = b"i\0";
pub const PRIiLEAST16: &[u8; 2] = b"i\0";
pub const PRIiLEAST32: &[u8; 2] = b"i\0";
pub const PRIiLEAST64: &[u8; 3] = b"li\0";
pub const PRIiFAST8: &[u8; 2] = b"i\0";
pub const PRIiFAST16: &[u8; 3] = b"li\0";
pub const PRIiFAST32: &[u8; 3] = b"li\0";
pub const PRIiFAST64: &[u8; 3] = b"li\0";
pub const PRIo8: &[u8; 2] = b"o\0";
pub const PRIo16: &[u8; 2] = b"o\0";
pub const PRIo32: &[u8; 2] = b"o\0";
pub const PRIo64: &[u8; 3] = b"lo\0";
pub const PRIoLEAST8: &[u8; 2] = b"o\0";
pub const PRIoLEAST16: &[u8; 2] = b"o\0";
pub const PRIoLEAST32: &[u8; 2] = b"o\0";
pub const PRIoLEAST64: &[u8; 3] = b"lo\0";
pub const PRIoFAST8: &[u8; 2] = b"o\0";
pub const PRIoFAST16: &[u8; 3] = b"lo\0";
pub const PRIoFAST32: &[u8; 3] = b"lo\0";
pub const PRIoFAST64: &[u8; 3] = b"lo\0";
pub const PRIu8: &[u8; 2] = b"u\0";
pub const PRIu16: &[u8; 2] = b"u\0";
pub const PRIu32: &[u8; 2] = b"u\0";
pub const PRIu64: &[u8; 3] = b"lu\0";
pub const PRIuLEAST8: &[u8; 2] = b"u\0";
pub const PRIuLEAST16: &[u8; 2] = b"u\0";
pub const PRIuLEAST32: &[u8; 2] = b"u\0";
pub const PRIuLEAST64: &[u8; 3] = b"lu\0";
pub const PRIuFAST8: &[u8; 2] = b"u\0";
pub const PRIuFAST16: &[u8; 3] = b"lu\0";
pub const PRIuFAST32: &[u8; 3] = b"lu\0";
pub const PRIuFAST64: &[u8; 3] = b"lu\0";
pub const PRIx8: &[u8; 2] = b"x\0";
pub const PRIx16: &[u8; 2] = b"x\0";
pub const PRIx32: &[u8; 2] = b"x\0";
pub const PRIx64: &[u8; 3] = b"lx\0";
pub const PRIxLEAST8: &[u8; 2] = b"x\0";
pub const PRIxLEAST16: &[u8; 2] = b"x\0";
pub const PRIxLEAST32: &[u8; 2] = b"x\0";
pub const PRIxLEAST64: &[u8; 3] = b"lx\0";
pub const PRIxFAST8: &[u8; 2] = b"x\0";
pub const PRIxFAST16: &[u8; 3] = b"lx\0";
pub const PRIxFAST32: &[u8; 3] = b"lx\0";
pub const PRIxFAST64: &[u8; 3] = b"lx\0";
pub const PRIX8: &[u8; 2] = b"X\0";
pub const PRIX16: &[u8; 2] = b"X\0";
pub const PRIX32: &[u8; 2] = b"X\0";
pub const PRIX64: &[u8; 3] = b"lX\0";
pub const PRIXLEAST8: &[u8; 2] = b"X\0";
pub const PRIXLEAST16: &[u8; 2] = b"X\0";
pub const PRIXLEAST32: &[u8; 2] = b"X\0";
pub const PRIXLEAST64: &[u8; 3] = b"lX\0";
pub const PRIXFAST8: &[u8; 2] = b"X\0";
pub const PRIXFAST16: &[u8; 3] = b"lX\0";
pub const PRIXFAST32: &[u8; 3] = b"lX\0";
pub const PRIXFAST64: &[u8; 3] = b"lX\0";
pub const PRIdMAX: &[u8; 3] = b"ld\0";
pub const PRIiMAX: &[u8; 3] = b"li\0";
pub const PRIoMAX: &[u8; 3] = b"lo\0";
pub const PRIuMAX: &[u8; 3] = b"lu\0";
pub const PRIxMAX: &[u8; 3] = b"lx\0";
pub const PRIXMAX: &[u8; 3] = b"lX\0";
pub const PRIdPTR: &[u8; 3] = b"ld\0";
pub const PRIiPTR: &[u8; 3] = b"li\0";
pub const PRIoPTR: &[u8; 3] = b"lo\0";
pub const PRIuPTR: &[u8; 3] = b"lu\0";
pub const PRIxPTR: &[u8; 3] = b"lx\0";
pub const PRIXPTR: &[u8; 3] = b"lX\0";
pub const SCNd8: &[u8; 4] = b"hhd\0";
pub const SCNd16: &[u8; 3] = b"hd\0";
pub const SCNd32: &[u8; 2] = b"d\0";
pub const SCNd64: &[u8; 3] = b"ld\0";
pub const SCNdLEAST8: &[u8; 4] = b"hhd\0";
pub const SCNdLEAST16: &[u8; 3] = b"hd\0";
pub const SCNdLEAST32: &[u8; 2] = b"d\0";
pub const SCNdLEAST64: &[u8; 3] = b"ld\0";
pub const SCNdFAST8: &[u8; 4] = b"hhd\0";
pub const SCNdFAST16: &[u8; 3] = b"ld\0";
pub const SCNdFAST32: &[u8; 3] = b"ld\0";
pub const SCNdFAST64: &[u8; 3] = b"ld\0";
pub const SCNi8: &[u8; 4] = b"hhi\0";
pub const SCNi16: &[u8; 3] = b"hi\0";
pub const SCNi32: &[u8; 2] = b"i\0";
pub const SCNi64: &[u8; 3] = b"li\0";
pub const SCNiLEAST8: &[u8; 4] = b"hhi\0";
pub const SCNiLEAST16: &[u8; 3] = b"hi\0";
pub const SCNiLEAST32: &[u8; 2] = b"i\0";
pub const SCNiLEAST64: &[u8; 3] = b"li\0";
pub const SCNiFAST8: &[u8; 4] = b"hhi\0";
pub const SCNiFAST16: &[u8; 3] = b"li\0";
pub const SCNiFAST32: &[u8; 3] = b"li\0";
pub const SCNiFAST64: &[u8; 3] = b"li\0";
pub const SCNu8: &[u8; 4] = b"hhu\0";
pub const SCNu16: &[u8; 3] = b"hu\0";
pub const SCNu32: &[u8; 2] = b"u\0";
pub const SCNu64: &[u8; 3] = b"lu\0";
pub const SCNuLEAST8: &[u8; 4] = b"hhu\0";
pub const SCNuLEAST16: &[u8; 3] = b"hu\0";
pub const SCNuLEAST32: &[u8; 2] = b"u\0";
pub const SCNuLEAST64: &[u8; 3] = b"lu\0";
pub const SCNuFAST8: &[u8; 4] = b"hhu\0";
pub const SCNuFAST16: &[u8; 3] = b"lu\0";
pub const SCNuFAST32: &[u8; 3] = b"lu\0";
pub const SCNuFAST64: &[u8; 3] = b"lu\0";
pub const SCNo8: &[u8; 4] = b"hho\0";
pub const SCNo16: &[u8; 3] = b"ho\0";
pub const SCNo32: &[u8; 2] = b"o\0";
pub const SCNo64: &[u8; 3] = b"lo\0";
pub const SCNoLEAST8: &[u8; 4] = b"hho\0";
pub const SCNoLEAST16: &[u8; 3] = b"ho\0";
pub const SCNoLEAST32: &[u8; 2] = b"o\0";
pub const SCNoLEAST64: &[u8; 3] = b"lo\0";
pub const SCNoFAST8: &[u8; 4] = b"hho\0";
pub const SCNoFAST16: &[u8; 3] = b"lo\0";
pub const SCNoFAST32: &[u8; 3] = b"lo\0";
pub const SCNoFAST64: &[u8; 3] = b"lo\0";
pub const SCNx8: &[u8; 4] = b"hhx\0";
pub const SCNx16: &[u8; 3] = b"hx\0";
pub const SCNx32: &[u8; 2] = b"x\0";
pub const SCNx64: &[u8; 3] = b"lx\0";
pub const SCNxLEAST8: &[u8; 4] = b"hhx\0";
pub const SCNxLEAST16: &[u8; 3] = b"hx\0";
pub const SCNxLEAST32: &[u8; 2] = b"x\0";
pub const SCNxLEAST64: &[u8; 3] = b"lx\0";
pub const SCNxFAST8: &[u8; 4] = b"hhx\0";
pub const SCNxFAST16: &[u8; 3] = b"lx\0";
pub const SCNxFAST32: &[u8; 3] = b"lx\0";
pub const SCNxFAST64: &[u8; 3] = b"lx\0";
pub const SCNdMAX: &[u8; 3] = b"ld\0";
pub const SCNiMAX: &[u8; 3] = b"li\0";
pub const SCNoMAX: &[u8; 3] = b"lo\0";
pub const SCNuMAX: &[u8; 3] = b"lu\0";
pub const SCNxMAX: &[u8; 3] = b"lx\0";
pub const SCNdPTR: &[u8; 3] = b"ld\0";
pub const SCNiPTR: &[u8; 3] = b"li\0";
pub const SCNoPTR: &[u8; 3] = b"lo\0";
pub const SCNuPTR: &[u8; 3] = b"lu\0";
pub const SCNxPTR: &[u8; 3] = b"lx\0";
pub const _MATH_H: u32 = 1;
pub const _BITS_LIBM_SIMD_DECL_STUBS_H: u32 = 1;
pub const __FP_LOGB0_IS_MIN: u32 = 1;
pub const __FP_LOGBNAN_IS_MIN: u32 = 1;
pub const FP_ILOGB0: i32 = -2147483648;
pub const FP_ILOGBNAN: i32 = -2147483648;
pub const __MATH_DECLARING_DOUBLE: u32 = 1;
pub const __MATH_DECLARING_FLOATN: u32 = 0;
pub const __MATH_DECLARE_LDOUBLE: u32 = 1;
pub const MATH_ERRNO: u32 = 1;
pub const MATH_ERREXCEPT: u32 = 2;
pub const math_errhandling: u32 = 3;
pub const M_E: f64 = 2.718281828459045;
pub const M_LOG2E: f64 = 1.4426950408889634;
pub const M_LOG10E: f64 = 0.4342944819032518;
pub const M_LN2: f64 = 0.6931471805599453;
pub const M_LN10: f64 = 2.302585092994046;
pub const M_PI: f64 = 3.141592653589793;
pub const M_PI_2: f64 = 1.5707963267948966;
pub const M_PI_4: f64 = 0.7853981633974483;
pub const M_1_PI: f64 = 0.3183098861837907;
pub const M_2_PI: f64 = 0.6366197723675814;
pub const M_2_SQRTPI: f64 = 1.1283791670955126;
pub const M_SQRT2: f64 = 1.4142135623730951;
pub const M_SQRT1_2: f64 = 0.7071067811865476;
pub const LAYER_INIT_SHA: i32 = -1;
pub const _STDIO_H: u32 = 1;
pub const _____fpos_t_defined: u32 = 1;
pub const ____mbstate_t_defined: u32 = 1;
pub const _____fpos64_t_defined: u32 = 1;
pub const ____FILE_defined: u32 = 1;
pub const __FILE_defined: u32 = 1;
pub const __struct_FILE_defined: u32 = 1;
pub const _IO_EOF_SEEN: u32 = 16;
pub const _IO_ERR_SEEN: u32 = 32;
pub const _IO_USER_LOCK: u32 = 32768;
pub const __cookie_io_functions_t_defined: u32 = 1;
pub const _IOFBF: u32 = 0;
pub const _IOLBF: u32 = 1;
pub const _IONBF: u32 = 2;
pub const BUFSIZ: u32 = 8192;
pub const EOF: i32 = -1;
pub const SEEK_SET: u32 = 0;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const P_tmpdir: &[u8; 5] = b"/tmp\0";
pub const L_tmpnam: u32 = 20;
pub const TMP_MAX: u32 = 238328;
pub const _BITS_STDIO_LIM_H: u32 = 1;
pub const FILENAME_MAX: u32 = 4096;
pub const L_ctermid: u32 = 9;
pub const FOPEN_MAX: u32 = 16;
pub const MCVersion_MC_UNDEF: MCVersion = 0;
pub const MCVersion_MC_B1_7: MCVersion = 1;
pub const MCVersion_MC_B1_8: MCVersion = 2;
pub const MCVersion_MC_1_0_0: MCVersion = 3;
pub const MCVersion_MC_1_0: MCVersion = 3;
pub const MCVersion_MC_1_1_0: MCVersion = 4;
pub const MCVersion_MC_1_1: MCVersion = 4;
pub const MCVersion_MC_1_2_5: MCVersion = 5;
pub const MCVersion_MC_1_2: MCVersion = 5;
pub const MCVersion_MC_1_3_2: MCVersion = 6;
pub const MCVersion_MC_1_3: MCVersion = 6;
pub const MCVersion_MC_1_4_7: MCVersion = 7;
pub const MCVersion_MC_1_4: MCVersion = 7;
pub const MCVersion_MC_1_5_2: MCVersion = 8;
pub const MCVersion_MC_1_5: MCVersion = 8;
pub const MCVersion_MC_1_6_4: MCVersion = 9;
pub const MCVersion_MC_1_6: MCVersion = 9;
pub const MCVersion_MC_1_7_10: MCVersion = 10;
pub const MCVersion_MC_1_7: MCVersion = 10;
pub const MCVersion_MC_1_8_9: MCVersion = 11;
pub const MCVersion_MC_1_8: MCVersion = 11;
pub const MCVersion_MC_1_9_4: MCVersion = 12;
pub const MCVersion_MC_1_9: MCVersion = 12;
pub const MCVersion_MC_1_10_2: MCVersion = 13;
pub const MCVersion_MC_1_10: MCVersion = 13;
pub const MCVersion_MC_1_11_2: MCVersion = 14;
pub const MCVersion_MC_1_11: MCVersion = 14;
pub const MCVersion_MC_1_12_2: MCVersion = 15;
pub const MCVersion_MC_1_12: MCVersion = 15;
pub const MCVersion_MC_1_13_2: MCVersion = 16;
pub const MCVersion_MC_1_13: MCVersion = 16;
pub const MCVersion_MC_1_14_4: MCVersion = 17;
pub const MCVersion_MC_1_14: MCVersion = 17;
pub const MCVersion_MC_1_15_2: MCVersion = 18;
pub const MCVersion_MC_1_15: MCVersion = 18;
pub const MCVersion_MC_1_16_1: MCVersion = 19;
pub const MCVersion_MC_1_16_5: MCVersion = 20;
pub const MCVersion_MC_1_16: MCVersion = 20;
pub const MCVersion_MC_1_17_1: MCVersion = 21;
pub const MCVersion_MC_1_17: MCVersion = 21;
pub const MCVersion_MC_1_18_2: MCVersion = 22;
pub const MCVersion_MC_1_18: MCVersion = 22;
pub const MCVersion_MC_1_19_2: MCVersion = 23;
pub const MCVersion_MC_1_19: MCVersion = 24;
pub const MCVersion_MC_1_20: MCVersion = 25;
pub const MCVersion_MC_NEWEST: MCVersion = 25;
pub type MCVersion = ::std::os::raw::c_uint;
pub const Dimension_DIM_NETHER: Dimension = -1;
pub const Dimension_DIM_OVERWORLD: Dimension = 0;
pub const Dimension_DIM_END: Dimension = 1;
pub const Dimension_DIM_UNDEF: Dimension = 1000;
pub type Dimension = ::std::os::raw::c_int;
pub const BiomeID_none: BiomeID = -1;
pub const BiomeID_ocean: BiomeID = 0;
pub const BiomeID_plains: BiomeID = 1;
pub const BiomeID_desert: BiomeID = 2;
pub const BiomeID_mountains: BiomeID = 3;
pub const BiomeID_extremeHills: BiomeID = 3;
pub const BiomeID_forest: BiomeID = 4;
pub const BiomeID_taiga: BiomeID = 5;
pub const BiomeID_swamp: BiomeID = 6;
pub const BiomeID_swampland: BiomeID = 6;
pub const BiomeID_river: BiomeID = 7;
pub const BiomeID_nether_wastes: BiomeID = 8;
pub const BiomeID_hell: BiomeID = 8;
pub const BiomeID_the_end: BiomeID = 9;
pub const BiomeID_sky: BiomeID = 9;
pub const BiomeID_frozen_ocean: BiomeID = 10;
pub const BiomeID_frozenOcean: BiomeID = 10;
pub const BiomeID_frozen_river: BiomeID = 11;
pub const BiomeID_frozenRiver: BiomeID = 11;
pub const BiomeID_snowy_tundra: BiomeID = 12;
pub const BiomeID_icePlains: BiomeID = 12;
pub const BiomeID_snowy_mountains: BiomeID = 13;
pub const BiomeID_iceMountains: BiomeID = 13;
pub const BiomeID_mushroom_fields: BiomeID = 14;
pub const BiomeID_mushroomIsland: BiomeID = 14;
pub const BiomeID_mushroom_field_shore: BiomeID = 15;
pub const BiomeID_mushroomIslandShore: BiomeID = 15;
pub const BiomeID_beach: BiomeID = 16;
pub const BiomeID_desert_hills: BiomeID = 17;
pub const BiomeID_desertHills: BiomeID = 17;
pub const BiomeID_wooded_hills: BiomeID = 18;
pub const BiomeID_forestHills: BiomeID = 18;
pub const BiomeID_taiga_hills: BiomeID = 19;
pub const BiomeID_taigaHills: BiomeID = 19;
pub const BiomeID_mountain_edge: BiomeID = 20;
pub const BiomeID_extremeHillsEdge: BiomeID = 20;
pub const BiomeID_jungle: BiomeID = 21;
pub const BiomeID_jungle_hills: BiomeID = 22;
pub const BiomeID_jungleHills: BiomeID = 22;
pub const BiomeID_jungle_edge: BiomeID = 23;
pub const BiomeID_jungleEdge: BiomeID = 23;
pub const BiomeID_deep_ocean: BiomeID = 24;
pub const BiomeID_deepOcean: BiomeID = 24;
pub const BiomeID_stone_shore: BiomeID = 25;
pub const BiomeID_stoneBeach: BiomeID = 25;
pub const BiomeID_snowy_beach: BiomeID = 26;
pub const BiomeID_coldBeach: BiomeID = 26;
pub const BiomeID_birch_forest: BiomeID = 27;
pub const BiomeID_birchForest: BiomeID = 27;
pub const BiomeID_birch_forest_hills: BiomeID = 28;
pub const BiomeID_birchForestHills: BiomeID = 28;
pub const BiomeID_dark_forest: BiomeID = 29;
pub const BiomeID_roofedForest: BiomeID = 29;
pub const BiomeID_snowy_taiga: BiomeID = 30;
pub const BiomeID_coldTaiga: BiomeID = 30;
pub const BiomeID_snowy_taiga_hills: BiomeID = 31;
pub const BiomeID_coldTaigaHills: BiomeID = 31;
pub const BiomeID_giant_tree_taiga: BiomeID = 32;
pub const BiomeID_megaTaiga: BiomeID = 32;
pub const BiomeID_giant_tree_taiga_hills: BiomeID = 33;
pub const BiomeID_megaTaigaHills: BiomeID = 33;
pub const BiomeID_wooded_mountains: BiomeID = 34;
pub const BiomeID_extremeHillsPlus: BiomeID = 34;
pub const BiomeID_savanna: BiomeID = 35;
pub const BiomeID_savanna_plateau: BiomeID = 36;
pub const BiomeID_savannaPlateau: BiomeID = 36;
pub const BiomeID_badlands: BiomeID = 37;
pub const BiomeID_mesa: BiomeID = 37;
pub const BiomeID_wooded_badlands_plateau: BiomeID = 38;
pub const BiomeID_mesaPlateau_F: BiomeID = 38;
pub const BiomeID_badlands_plateau: BiomeID = 39;
pub const BiomeID_mesaPlateau: BiomeID = 39;
pub const BiomeID_small_end_islands: BiomeID = 40;
pub const BiomeID_end_midlands: BiomeID = 41;
pub const BiomeID_end_highlands: BiomeID = 42;
pub const BiomeID_end_barrens: BiomeID = 43;
pub const BiomeID_warm_ocean: BiomeID = 44;
pub const BiomeID_warmOcean: BiomeID = 44;
pub const BiomeID_lukewarm_ocean: BiomeID = 45;
pub const BiomeID_lukewarmOcean: BiomeID = 45;
pub const BiomeID_cold_ocean: BiomeID = 46;
pub const BiomeID_coldOcean: BiomeID = 46;
pub const BiomeID_deep_warm_ocean: BiomeID = 47;
pub const BiomeID_warmDeepOcean: BiomeID = 47;
pub const BiomeID_deep_lukewarm_ocean: BiomeID = 48;
pub const BiomeID_lukewarmDeepOcean: BiomeID = 48;
pub const BiomeID_deep_cold_ocean: BiomeID = 49;
pub const BiomeID_coldDeepOcean: BiomeID = 49;
pub const BiomeID_deep_frozen_ocean: BiomeID = 50;
pub const BiomeID_frozenDeepOcean: BiomeID = 50;
pub const BiomeID_seasonal_forest: BiomeID = 51;
pub const BiomeID_rainforest: BiomeID = 52;
pub const BiomeID_shrubland: BiomeID = 53;
pub const BiomeID_the_void: BiomeID = 127;
pub const BiomeID_sunflower_plains: BiomeID = 129;
pub const BiomeID_desert_lakes: BiomeID = 130;
pub const BiomeID_gravelly_mountains: BiomeID = 131;
pub const BiomeID_flower_forest: BiomeID = 132;
pub const BiomeID_taiga_mountains: BiomeID = 133;
pub const BiomeID_swamp_hills: BiomeID = 134;
pub const BiomeID_ice_spikes: BiomeID = 140;
pub const BiomeID_modified_jungle: BiomeID = 149;
pub const BiomeID_modified_jungle_edge: BiomeID = 151;
pub const BiomeID_tall_birch_forest: BiomeID = 155;
pub const BiomeID_tall_birch_hills: BiomeID = 156;
pub const BiomeID_dark_forest_hills: BiomeID = 157;
pub const BiomeID_snowy_taiga_mountains: BiomeID = 158;
pub const BiomeID_giant_spruce_taiga: BiomeID = 160;
pub const BiomeID_giant_spruce_taiga_hills: BiomeID = 161;
pub const BiomeID_modified_gravelly_mountains: BiomeID = 162;
pub const BiomeID_shattered_savanna: BiomeID = 163;
pub const BiomeID_shattered_savanna_plateau: BiomeID = 164;
pub const BiomeID_eroded_badlands: BiomeID = 165;
pub const BiomeID_modified_wooded_badlands_plateau: BiomeID = 166;
pub const BiomeID_modified_badlands_plateau: BiomeID = 167;
pub const BiomeID_bamboo_jungle: BiomeID = 168;
pub const BiomeID_bamboo_jungle_hills: BiomeID = 169;
pub const BiomeID_soul_sand_valley: BiomeID = 170;
pub const BiomeID_crimson_forest: BiomeID = 171;
pub const BiomeID_warped_forest: BiomeID = 172;
pub const BiomeID_basalt_deltas: BiomeID = 173;
pub const BiomeID_dripstone_caves: BiomeID = 174;
pub const BiomeID_lush_caves: BiomeID = 175;
pub const BiomeID_meadow: BiomeID = 177;
pub const BiomeID_grove: BiomeID = 178;
pub const BiomeID_snowy_slopes: BiomeID = 179;
pub const BiomeID_jagged_peaks: BiomeID = 180;
pub const BiomeID_frozen_peaks: BiomeID = 181;
pub const BiomeID_stony_peaks: BiomeID = 182;
pub const BiomeID_old_growth_birch_forest: BiomeID = 155;
pub const BiomeID_old_growth_pine_taiga: BiomeID = 32;
pub const BiomeID_old_growth_spruce_taiga: BiomeID = 160;
pub const BiomeID_snowy_plains: BiomeID = 12;
pub const BiomeID_sparse_jungle: BiomeID = 23;
pub const BiomeID_stony_shore: BiomeID = 25;
pub const BiomeID_windswept_hills: BiomeID = 3;
pub const BiomeID_windswept_forest: BiomeID = 34;
pub const BiomeID_windswept_gravelly_hills: BiomeID = 131;
pub const BiomeID_windswept_savanna: BiomeID = 163;
pub const BiomeID_wooded_badlands: BiomeID = 38;
pub const BiomeID_deep_dark: BiomeID = 183;
pub const BiomeID_mangrove_swamp: BiomeID = 184;
pub const BiomeID_cherry_grove: BiomeID = 185;
pub type BiomeID = ::std::os::raw::c_int;
pub type wchar_t = ::std::os::raw::c_int;
pub type _Float32 = f32;
pub type _Float64 = f64;
pub type _Float32x = f64;
pub type _Float64x = u128;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct div_t {
    pub quot: ::std::os::raw::c_int,
    pub rem: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_div_t() {
    const UNINIT: ::std::mem::MaybeUninit<div_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<div_t>(),
        8usize,
        concat!("Size of: ", stringify!(div_t))
    );
    assert_eq!(
        ::std::mem::align_of::<div_t>(),
        4usize,
        concat!("Alignment of ", stringify!(div_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(div_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(div_t),
            "::",
            stringify!(rem)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct ldiv_t {
    pub quot: ::std::os::raw::c_long,
    pub rem: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_ldiv_t() {
    const UNINIT: ::std::mem::MaybeUninit<ldiv_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(ldiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(ldiv_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct lldiv_t {
    pub quot: ::std::os::raw::c_longlong,
    pub rem: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout_lldiv_t() {
    const UNINIT: ::std::mem::MaybeUninit<lldiv_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<lldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(lldiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<lldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(lldiv_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
extern "C" {
    pub fn __ctype_get_mb_cur_max() -> usize;
}
extern "C" {
    pub fn atof(__nptr: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn atoi(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atol(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn atoll(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtod(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> f64;
}
extern "C" {
    pub fn strtof(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> f32;
}
extern "C" {
    pub fn strtold(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> u128;
}
extern "C" {
    pub fn strtol(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn strtoul(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strtoq(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtouq(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn strtoll(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtoull(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn l64a(__n: ::std::os::raw::c_long) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn a64l(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    const UNINIT: ::std::mem::MaybeUninit<__fsid_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__fsid_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __suseconds64_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
pub type u_char = __u_char;
pub type u_short = __u_short;
pub type u_int = __u_int;
pub type u_long = __u_long;
pub type quad_t = __quad_t;
pub type u_quad_t = __u_quad_t;
pub type fsid_t = __fsid_t;
pub type loff_t = __loff_t;
pub type ino_t = __ino_t;
pub type dev_t = __dev_t;
pub type gid_t = __gid_t;
pub type mode_t = __mode_t;
pub type nlink_t = __nlink_t;
pub type uid_t = __uid_t;
pub type off_t = __off_t;
pub type pid_t = __pid_t;
pub type id_t = __id_t;
pub type daddr_t = __daddr_t;
pub type caddr_t = __caddr_t;
pub type key_t = __key_t;
pub type clock_t = __clock_t;
pub type clockid_t = __clockid_t;
pub type time_t = __time_t;
pub type timer_t = __timer_t;
pub type ulong = ::std::os::raw::c_ulong;
pub type ushort = ::std::os::raw::c_ushort;
pub type uint = ::std::os::raw::c_uint;
pub type u_int8_t = __uint8_t;
pub type u_int16_t = __uint16_t;
pub type u_int32_t = __uint32_t;
pub type u_int64_t = __uint64_t;
pub type register_t = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct __sigset_t {
    pub __val: [::std::os::raw::c_ulong; 16usize],
}
#[test]
fn bindgen_test_layout___sigset_t() {
    const UNINIT: ::std::mem::MaybeUninit<__sigset_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__sigset_t>(),
        128usize,
        concat!("Size of: ", stringify!(__sigset_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__sigset_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__sigset_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigset_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type sigset_t = __sigset_t;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct timeval {
    pub tv_sec: __time_t,
    pub tv_usec: __suseconds_t,
}
#[test]
fn bindgen_test_layout_timeval() {
    const UNINIT: ::std::mem::MaybeUninit<timeval> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<timeval>(),
        16usize,
        concat!("Size of: ", stringify!(timeval))
    );
    assert_eq!(
        ::std::mem::align_of::<timeval>(),
        8usize,
        concat!("Alignment of ", stringify!(timeval))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_usec) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_usec)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
#[test]
fn bindgen_test_layout_timespec() {
    const UNINIT: ::std::mem::MaybeUninit<timespec> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<timespec>(),
        16usize,
        concat!("Size of: ", stringify!(timespec))
    );
    assert_eq!(
        ::std::mem::align_of::<timespec>(),
        8usize,
        concat!("Alignment of ", stringify!(timespec))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_nsec) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_nsec)
        )
    );
}
pub type suseconds_t = __suseconds_t;
pub type __fd_mask = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct fd_set {
    pub __fds_bits: [__fd_mask; 16usize],
}
#[test]
fn bindgen_test_layout_fd_set() {
    const UNINIT: ::std::mem::MaybeUninit<fd_set> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<fd_set>(),
        128usize,
        concat!("Size of: ", stringify!(fd_set))
    );
    assert_eq!(
        ::std::mem::align_of::<fd_set>(),
        8usize,
        concat!("Alignment of ", stringify!(fd_set))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fds_bits) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fd_set),
            "::",
            stringify!(__fds_bits)
        )
    );
}
pub type fd_mask = __fd_mask;
extern "C" {
    pub fn select(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *mut timeval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pselect(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *const timespec,
        __sigmask: *const __sigset_t,
    ) -> ::std::os::raw::c_int;
}
pub type blksize_t = __blksize_t;
pub type blkcnt_t = __blkcnt_t;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub union __atomic_wide_counter {
    pub __value64: ::std::os::raw::c_ulonglong,
    pub __value32: __atomic_wide_counter__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct __atomic_wide_counter__bindgen_ty_1 {
    pub __low: ::std::os::raw::c_uint,
    pub __high: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___atomic_wide_counter__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<__atomic_wide_counter__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__atomic_wide_counter__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(__atomic_wide_counter__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<__atomic_wide_counter__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(__atomic_wide_counter__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__low) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__atomic_wide_counter__bindgen_ty_1),
            "::",
            stringify!(__low)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__high) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__atomic_wide_counter__bindgen_ty_1),
            "::",
            stringify!(__high)
        )
    );
}
#[test]
fn bindgen_test_layout___atomic_wide_counter() {
    const UNINIT: ::std::mem::MaybeUninit<__atomic_wide_counter> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__atomic_wide_counter>(),
        8usize,
        concat!("Size of: ", stringify!(__atomic_wide_counter))
    );
    assert_eq!(
        ::std::mem::align_of::<__atomic_wide_counter>(),
        8usize,
        concat!("Alignment of ", stringify!(__atomic_wide_counter))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__value64) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__atomic_wide_counter),
            "::",
            stringify!(__value64)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__value32) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__atomic_wide_counter),
            "::",
            stringify!(__value32)
        )
    );
}
impl Default for __atomic_wide_counter {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct __pthread_internal_list {
    pub __prev: *mut __pthread_internal_list,
    pub __next: *mut __pthread_internal_list,
}
#[test]
fn bindgen_test_layout___pthread_internal_list() {
    const UNINIT: ::std::mem::MaybeUninit<__pthread_internal_list> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_internal_list>(),
        16usize,
        concat!("Size of: ", stringify!(__pthread_internal_list))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_internal_list>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_internal_list))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__prev) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_list),
            "::",
            stringify!(__prev)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__next) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_list),
            "::",
            stringify!(__next)
        )
    );
}
impl Default for __pthread_internal_list {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type __pthread_list_t = __pthread_internal_list;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct __pthread_internal_slist {
    pub __next: *mut __pthread_internal_slist,
}
#[test]
fn bindgen_test_layout___pthread_internal_slist() {
    const UNINIT: ::std::mem::MaybeUninit<__pthread_internal_slist> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_internal_slist>(),
        8usize,
        concat!("Size of: ", stringify!(__pthread_internal_slist))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_internal_slist>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_internal_slist))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_slist),
            "::",
            stringify!(__next)
        )
    );
}
impl Default for __pthread_internal_slist {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type __pthread_slist_t = __pthread_internal_slist;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct __pthread_mutex_s {
    pub __lock: ::std::os::raw::c_int,
    pub __count: ::std::os::raw::c_uint,
    pub __owner: ::std::os::raw::c_int,
    pub __nusers: ::std::os::raw::c_uint,
    pub __kind: ::std::os::raw::c_int,
    pub __spins: ::std::os::raw::c_short,
    pub __elision: ::std::os::raw::c_short,
    pub __list: __pthread_list_t,
}
#[test]
fn bindgen_test_layout___pthread_mutex_s() {
    const UNINIT: ::std::mem::MaybeUninit<__pthread_mutex_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_mutex_s>(),
        40usize,
        concat!("Size of: ", stringify!(__pthread_mutex_s))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_mutex_s>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_mutex_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__lock) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__lock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__count) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__owner) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__owner)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__nusers) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__nusers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__kind) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__kind)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__spins) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__spins)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__elision) as usize - ptr as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__elision)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__list) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__list)
        )
    );
}
impl Default for __pthread_mutex_s {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct __pthread_rwlock_arch_t {
    pub __readers: ::std::os::raw::c_uint,
    pub __writers: ::std::os::raw::c_uint,
    pub __wrphase_futex: ::std::os::raw::c_uint,
    pub __writers_futex: ::std::os::raw::c_uint,
    pub __pad3: ::std::os::raw::c_uint,
    pub __pad4: ::std::os::raw::c_uint,
    pub __cur_writer: ::std::os::raw::c_int,
    pub __shared: ::std::os::raw::c_int,
    pub __rwelision: ::std::os::raw::c_schar,
    pub __pad1: [::std::os::raw::c_uchar; 7usize],
    pub __pad2: ::std::os::raw::c_ulong,
    pub __flags: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___pthread_rwlock_arch_t() {
    const UNINIT: ::std::mem::MaybeUninit<__pthread_rwlock_arch_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_rwlock_arch_t>(),
        56usize,
        concat!("Size of: ", stringify!(__pthread_rwlock_arch_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_rwlock_arch_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_rwlock_arch_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__readers) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__readers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__writers) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__writers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wrphase_futex) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__wrphase_futex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__writers_futex) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__writers_futex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad3) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad4) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad4)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__cur_writer) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__cur_writer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__shared) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__shared)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__rwelision) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__rwelision)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad1) as usize - ptr as usize },
        33usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad2) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__flags) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__flags)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __pthread_cond_s {
    pub __wseq: __atomic_wide_counter,
    pub __g1_start: __atomic_wide_counter,
    pub __g_refs: [::std::os::raw::c_uint; 2usize],
    pub __g_size: [::std::os::raw::c_uint; 2usize],
    pub __g1_orig_size: ::std::os::raw::c_uint,
    pub __wrefs: ::std::os::raw::c_uint,
    pub __g_signals: [::std::os::raw::c_uint; 2usize],
}
#[test]
fn bindgen_test_layout___pthread_cond_s() {
    const UNINIT: ::std::mem::MaybeUninit<__pthread_cond_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s>(),
        48usize,
        concat!("Size of: ", stringify!(__pthread_cond_s))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cond_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wseq) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__wseq)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__g1_start) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g1_start)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__g_refs) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_refs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__g_size) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__g1_orig_size) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g1_orig_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wrefs) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__wrefs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__g_signals) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_signals)
        )
    );
}
impl Default for __pthread_cond_s {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type __tss_t = ::std::os::raw::c_uint;
pub type __thrd_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct __once_flag {
    pub __data: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___once_flag() {
    const UNINIT: ::std::mem::MaybeUninit<__once_flag> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__once_flag>(),
        4usize,
        concat!("Size of: ", stringify!(__once_flag))
    );
    assert_eq!(
        ::std::mem::align_of::<__once_flag>(),
        4usize,
        concat!("Alignment of ", stringify!(__once_flag))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__once_flag),
            "::",
            stringify!(__data)
        )
    );
}
pub type pthread_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutexattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_pthread_mutexattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_mutexattr_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_mutexattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_mutexattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_mutexattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_mutexattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutexattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutexattr_t),
            "::",
            stringify!(__align)
        )
    );
}
impl Default for pthread_mutexattr_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_condattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_pthread_condattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_condattr_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_condattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_condattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_condattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_condattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_condattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_condattr_t),
            "::",
            stringify!(__align)
        )
    );
}
impl Default for pthread_condattr_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type pthread_key_t = ::std::os::raw::c_uint;
pub type pthread_once_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_attr_t {
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_attr_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_attr_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_attr_t>(),
        56usize,
        concat!("Size of: ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_attr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(__align)
        )
    );
}
impl Default for pthread_attr_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutex_t {
    pub __data: __pthread_mutex_s,
    pub __size: [::std::os::raw::c_char; 40usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_mutex_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_mutex_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_mutex_t>(),
        40usize,
        concat!("Size of: ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_mutex_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__align)
        )
    );
}
impl Default for pthread_mutex_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_cond_t {
    pub __data: __pthread_cond_s,
    pub __size: [::std::os::raw::c_char; 48usize],
    pub __align: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout_pthread_cond_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_cond_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_cond_t>(),
        48usize,
        concat!("Size of: ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_cond_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__align)
        )
    );
}
impl Default for pthread_cond_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlock_t {
    pub __data: __pthread_rwlock_arch_t,
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_rwlock_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_rwlock_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_rwlock_t>(),
        56usize,
        concat!("Size of: ", stringify!(pthread_rwlock_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_rwlock_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_rwlock_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__align)
        )
    );
}
impl Default for pthread_rwlock_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlockattr_t {
    pub __size: [::std::os::raw::c_char; 8usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_rwlockattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_rwlockattr_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_rwlockattr_t>(),
        8usize,
        concat!("Size of: ", stringify!(pthread_rwlockattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_rwlockattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_rwlockattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlockattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlockattr_t),
            "::",
            stringify!(__align)
        )
    );
}
impl Default for pthread_rwlockattr_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type pthread_spinlock_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrier_t {
    pub __size: [::std::os::raw::c_char; 32usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_barrier_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_barrier_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_barrier_t>(),
        32usize,
        concat!("Size of: ", stringify!(pthread_barrier_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_barrier_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_barrier_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrier_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrier_t),
            "::",
            stringify!(__align)
        )
    );
}
impl Default for pthread_barrier_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrierattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_pthread_barrierattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_barrierattr_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_barrierattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_barrierattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_barrierattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_barrierattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrierattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrierattr_t),
            "::",
            stringify!(__align)
        )
    );
}
impl Default for pthread_barrierattr_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn random() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn srandom(__seed: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn initstate(
        __seed: ::std::os::raw::c_uint,
        __statebuf: *mut ::std::os::raw::c_char,
        __statelen: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn setstate(__statebuf: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct random_data {
    pub fptr: *mut i32,
    pub rptr: *mut i32,
    pub state: *mut i32,
    pub rand_type: ::std::os::raw::c_int,
    pub rand_deg: ::std::os::raw::c_int,
    pub rand_sep: ::std::os::raw::c_int,
    pub end_ptr: *mut i32,
}
#[test]
fn bindgen_test_layout_random_data() {
    const UNINIT: ::std::mem::MaybeUninit<random_data> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<random_data>(),
        48usize,
        concat!("Size of: ", stringify!(random_data))
    );
    assert_eq!(
        ::std::mem::align_of::<random_data>(),
        8usize,
        concat!("Alignment of ", stringify!(random_data))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(fptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rptr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).state) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rand_type) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rand_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rand_deg) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rand_deg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rand_sep) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rand_sep)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).end_ptr) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(end_ptr)
        )
    );
}
impl Default for random_data {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn random_r(__buf: *mut random_data, __result: *mut i32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srandom_r(
        __seed: ::std::os::raw::c_uint,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn initstate_r(
        __seed: ::std::os::raw::c_uint,
        __statebuf: *mut ::std::os::raw::c_char,
        __statelen: usize,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setstate_r(
        __statebuf: *mut ::std::os::raw::c_char,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rand() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srand(__seed: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn rand_r(__seed: *mut ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn drand48() -> f64;
}
extern "C" {
    pub fn erand48(__xsubi: *mut ::std::os::raw::c_ushort) -> f64;
}
extern "C" {
    pub fn lrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn nrand48(__xsubi: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn mrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn jrand48(__xsubi: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn srand48(__seedval: ::std::os::raw::c_long);
}
extern "C" {
    pub fn seed48(__seed16v: *mut ::std::os::raw::c_ushort) -> *mut ::std::os::raw::c_ushort;
}
extern "C" {
    pub fn lcong48(__param: *mut ::std::os::raw::c_ushort);
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct drand48_data {
    pub __x: [::std::os::raw::c_ushort; 3usize],
    pub __old_x: [::std::os::raw::c_ushort; 3usize],
    pub __c: ::std::os::raw::c_ushort,
    pub __init: ::std::os::raw::c_ushort,
    pub __a: ::std::os::raw::c_ulonglong,
}
#[test]
fn bindgen_test_layout_drand48_data() {
    const UNINIT: ::std::mem::MaybeUninit<drand48_data> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<drand48_data>(),
        24usize,
        concat!("Size of: ", stringify!(drand48_data))
    );
    assert_eq!(
        ::std::mem::align_of::<drand48_data>(),
        8usize,
        concat!("Alignment of ", stringify!(drand48_data))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__old_x) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__old_x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__c) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__c)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__init) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__init)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__a) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__a)
        )
    );
}
extern "C" {
    pub fn drand48_r(__buffer: *mut drand48_data, __result: *mut f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn erand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lrand48_r(
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nrand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mrand48_r(
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jrand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srand48_r(
        __seedval: ::std::os::raw::c_long,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn seed48_r(
        __seed16v: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lcong48_r(
        __param: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn arc4random() -> __uint32_t;
}
extern "C" {
    pub fn arc4random_buf(__buf: *mut ::std::os::raw::c_void, __size: usize);
}
extern "C" {
    pub fn arc4random_uniform(__upper_bound: __uint32_t) -> __uint32_t;
}
extern "C" {
    pub fn malloc(__size: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn calloc(
        __nmemb: ::std::os::raw::c_ulong,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn realloc(
        __ptr: *mut ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn free(__ptr: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn reallocarray(
        __ptr: *mut ::std::os::raw::c_void,
        __nmemb: usize,
        __size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn alloca(__size: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn valloc(__size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn posix_memalign(
        __memptr: *mut *mut ::std::os::raw::c_void,
        __alignment: usize,
        __size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aligned_alloc(
        __alignment: ::std::os::raw::c_ulong,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn abort() -> !;
}
extern "C" {
    pub fn atexit(__func: ::std::option::Option<unsafe extern "C" fn()>) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn at_quick_exit(
        __func: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn on_exit(
        __func: ::std::option::Option<
            unsafe extern "C" fn(
                __status: ::std::os::raw::c_int,
                __arg: *mut ::std::os::raw::c_void,
            ),
        >,
        __arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn exit(__status: ::std::os::raw::c_int) -> !;
}
extern "C" {
    pub fn quick_exit(__status: ::std::os::raw::c_int) -> !;
}
extern "C" {
    pub fn _Exit(__status: ::std::os::raw::c_int) -> !;
}
extern "C" {
    pub fn getenv(__name: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn putenv(__string: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setenv(
        __name: *const ::std::os::raw::c_char,
        __value: *const ::std::os::raw::c_char,
        __replace: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn unsetenv(__name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearenv() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mktemp(__template: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn mkstemp(__template: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkstemps(
        __template: *mut ::std::os::raw::c_char,
        __suffixlen: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkdtemp(__template: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn system(__command: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn realpath(
        __name: *const ::std::os::raw::c_char,
        __resolved: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
pub type __compar_fn_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn bsearch(
        __key: *const ::std::os::raw::c_void,
        __base: *const ::std::os::raw::c_void,
        __nmemb: usize,
        __size: usize,
        __compar: __compar_fn_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn qsort(
        __base: *mut ::std::os::raw::c_void,
        __nmemb: usize,
        __size: usize,
        __compar: __compar_fn_t,
    );
}
extern "C" {
    pub fn abs(__x: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn labs(__x: ::std::os::raw::c_long) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llabs(__x: ::std::os::raw::c_longlong) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn div(__numer: ::std::os::raw::c_int, __denom: ::std::os::raw::c_int) -> div_t;
}
extern "C" {
    pub fn ldiv(__numer: ::std::os::raw::c_long, __denom: ::std::os::raw::c_long) -> ldiv_t;
}
extern "C" {
    pub fn lldiv(
        __numer: ::std::os::raw::c_longlong,
        __denom: ::std::os::raw::c_longlong,
    ) -> lldiv_t;
}
extern "C" {
    pub fn ecvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fcvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn gcvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qecvt(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qfcvt(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qgcvt(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ecvt_r(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fcvt_r(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn qecvt_r(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn qfcvt_r(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mblen(__s: *const ::std::os::raw::c_char, __n: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbtowc(
        __pwc: *mut wchar_t,
        __s: *const ::std::os::raw::c_char,
        __n: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wctomb(__s: *mut ::std::os::raw::c_char, __wchar: wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbstowcs(__pwcs: *mut wchar_t, __s: *const ::std::os::raw::c_char, __n: usize) -> usize;
}
extern "C" {
    pub fn wcstombs(__s: *mut ::std::os::raw::c_char, __pwcs: *const wchar_t, __n: usize) -> usize;
}
extern "C" {
    pub fn rpmatch(__response: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getsubopt(
        __optionp: *mut *mut ::std::os::raw::c_char,
        __tokens: *const *mut ::std::os::raw::c_char,
        __valuep: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getloadavg(__loadavg: *mut f64, __nelem: ::std::os::raw::c_int)
        -> ::std::os::raw::c_int;
}
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Default, Copy, Clone, PartialOrd, PartialEq)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::std::os::raw::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: u128,
}
#[test]
fn bindgen_test_layout_max_align_t() {
    const UNINIT: ::std::mem::MaybeUninit<max_align_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<max_align_t>(),
        32usize,
        concat!("Size of: ", stringify!(max_align_t))
    );
    assert_eq!(
        ::std::mem::align_of::<max_align_t>(),
        16usize,
        concat!("Alignment of ", stringify!(max_align_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__clang_max_align_nonce1) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__clang_max_align_nonce2) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce2)
        )
    );
}
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub type __gwchar_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct imaxdiv_t {
    pub quot: ::std::os::raw::c_long,
    pub rem: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_imaxdiv_t() {
    const UNINIT: ::std::mem::MaybeUninit<imaxdiv_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<imaxdiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(imaxdiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<imaxdiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(imaxdiv_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(imaxdiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(imaxdiv_t),
            "::",
            stringify!(rem)
        )
    );
}
extern "C" {
    pub fn imaxabs(__n: intmax_t) -> intmax_t;
}
extern "C" {
    pub fn imaxdiv(__numer: intmax_t, __denom: intmax_t) -> imaxdiv_t;
}
extern "C" {
    pub fn strtoimax(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> intmax_t;
}
extern "C" {
    pub fn strtoumax(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> uintmax_t;
}
extern "C" {
    pub fn wcstoimax(
        __nptr: *const __gwchar_t,
        __endptr: *mut *mut __gwchar_t,
        __base: ::std::os::raw::c_int,
    ) -> intmax_t;
}
extern "C" {
    pub fn wcstoumax(
        __nptr: *const __gwchar_t,
        __endptr: *mut *mut __gwchar_t,
        __base: ::std::os::raw::c_int,
    ) -> uintmax_t;
}
#[doc = "=============================================================================\n                      Compiler and Platform Features\n============================================================================="]
pub type i8_ = i8;
pub type u8_ = u8;
pub type i16_ = i16;
pub type u16_ = u16;
pub type i32_ = i32;
pub type u32_ = u32;
pub type i64_ = i64;
pub type u64_ = u64;
pub type f32_ = f32;
pub type f64_ = f64;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct Xoroshiro {
    pub lo: u64,
    pub hi: u64,
}
#[test]
fn bindgen_test_layout_Xoroshiro() {
    const UNINIT: ::std::mem::MaybeUninit<Xoroshiro> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Xoroshiro>(),
        16usize,
        concat!("Size of: ", stringify!(Xoroshiro))
    );
    assert_eq!(
        ::std::mem::align_of::<Xoroshiro>(),
        8usize,
        concat!("Alignment of ", stringify!(Xoroshiro))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lo) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Xoroshiro),
            "::",
            stringify!(lo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hi) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Xoroshiro),
            "::",
            stringify!(hi)
        )
    );
}
pub type float_t = f32;
pub type double_t = f64;
extern "C" {
    pub fn __fpclassify(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __signbit(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __isinf(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __finite(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __isnan(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __iseqsig(__x: f64, __y: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __issignaling(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acos(__x: f64) -> f64;
}
extern "C" {
    pub fn __acos(__x: f64) -> f64;
}
extern "C" {
    pub fn asin(__x: f64) -> f64;
}
extern "C" {
    pub fn __asin(__x: f64) -> f64;
}
extern "C" {
    pub fn atan(__x: f64) -> f64;
}
extern "C" {
    pub fn __atan(__x: f64) -> f64;
}
extern "C" {
    pub fn atan2(__y: f64, __x: f64) -> f64;
}
extern "C" {
    pub fn __atan2(__y: f64, __x: f64) -> f64;
}
extern "C" {
    pub fn cos(__x: f64) -> f64;
}
extern "C" {
    pub fn __cos(__x: f64) -> f64;
}
extern "C" {
    pub fn sin(__x: f64) -> f64;
}
extern "C" {
    pub fn __sin(__x: f64) -> f64;
}
extern "C" {
    pub fn tan(__x: f64) -> f64;
}
extern "C" {
    pub fn __tan(__x: f64) -> f64;
}
extern "C" {
    pub fn cosh(__x: f64) -> f64;
}
extern "C" {
    pub fn __cosh(__x: f64) -> f64;
}
extern "C" {
    pub fn sinh(__x: f64) -> f64;
}
extern "C" {
    pub fn __sinh(__x: f64) -> f64;
}
extern "C" {
    pub fn tanh(__x: f64) -> f64;
}
extern "C" {
    pub fn __tanh(__x: f64) -> f64;
}
extern "C" {
    pub fn acosh(__x: f64) -> f64;
}
extern "C" {
    pub fn __acosh(__x: f64) -> f64;
}
extern "C" {
    pub fn asinh(__x: f64) -> f64;
}
extern "C" {
    pub fn __asinh(__x: f64) -> f64;
}
extern "C" {
    pub fn atanh(__x: f64) -> f64;
}
extern "C" {
    pub fn __atanh(__x: f64) -> f64;
}
extern "C" {
    pub fn exp(__x: f64) -> f64;
}
extern "C" {
    pub fn __exp(__x: f64) -> f64;
}
extern "C" {
    pub fn frexp(__x: f64, __exponent: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn __frexp(__x: f64, __exponent: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn ldexp(__x: f64, __exponent: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn __ldexp(__x: f64, __exponent: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn log(__x: f64) -> f64;
}
extern "C" {
    pub fn __log(__x: f64) -> f64;
}
extern "C" {
    pub fn log10(__x: f64) -> f64;
}
extern "C" {
    pub fn __log10(__x: f64) -> f64;
}
extern "C" {
    pub fn modf(__x: f64, __iptr: *mut f64) -> f64;
}
extern "C" {
    pub fn __modf(__x: f64, __iptr: *mut f64) -> f64;
}
extern "C" {
    pub fn expm1(__x: f64) -> f64;
}
extern "C" {
    pub fn __expm1(__x: f64) -> f64;
}
extern "C" {
    pub fn log1p(__x: f64) -> f64;
}
extern "C" {
    pub fn __log1p(__x: f64) -> f64;
}
extern "C" {
    pub fn logb(__x: f64) -> f64;
}
extern "C" {
    pub fn __logb(__x: f64) -> f64;
}
extern "C" {
    pub fn exp2(__x: f64) -> f64;
}
extern "C" {
    pub fn __exp2(__x: f64) -> f64;
}
extern "C" {
    pub fn log2(__x: f64) -> f64;
}
extern "C" {
    pub fn __log2(__x: f64) -> f64;
}
extern "C" {
    pub fn pow(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __pow(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn sqrt(__x: f64) -> f64;
}
extern "C" {
    pub fn __sqrt(__x: f64) -> f64;
}
extern "C" {
    pub fn hypot(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __hypot(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn cbrt(__x: f64) -> f64;
}
extern "C" {
    pub fn __cbrt(__x: f64) -> f64;
}
extern "C" {
    pub fn ceil(__x: f64) -> f64;
}
extern "C" {
    pub fn __ceil(__x: f64) -> f64;
}
extern "C" {
    pub fn fabs(__x: f64) -> f64;
}
extern "C" {
    pub fn __fabs(__x: f64) -> f64;
}
extern "C" {
    pub fn floor(__x: f64) -> f64;
}
extern "C" {
    pub fn __floor(__x: f64) -> f64;
}
extern "C" {
    pub fn fmod(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __fmod(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn isinf(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn finite(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn drem(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __drem(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn significand(__x: f64) -> f64;
}
extern "C" {
    pub fn __significand(__x: f64) -> f64;
}
extern "C" {
    pub fn copysign(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __copysign(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn nan(__tagb: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn __nan(__tagb: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn isnan(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn j0(arg1: f64) -> f64;
}
extern "C" {
    pub fn __j0(arg1: f64) -> f64;
}
extern "C" {
    pub fn j1(arg1: f64) -> f64;
}
extern "C" {
    pub fn __j1(arg1: f64) -> f64;
}
extern "C" {
    pub fn jn(arg1: ::std::os::raw::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn __jn(arg1: ::std::os::raw::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn y0(arg1: f64) -> f64;
}
extern "C" {
    pub fn __y0(arg1: f64) -> f64;
}
extern "C" {
    pub fn y1(arg1: f64) -> f64;
}
extern "C" {
    pub fn __y1(arg1: f64) -> f64;
}
extern "C" {
    pub fn yn(arg1: ::std::os::raw::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn __yn(arg1: ::std::os::raw::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn erf(arg1: f64) -> f64;
}
extern "C" {
    pub fn __erf(arg1: f64) -> f64;
}
extern "C" {
    pub fn erfc(arg1: f64) -> f64;
}
extern "C" {
    pub fn __erfc(arg1: f64) -> f64;
}
extern "C" {
    pub fn lgamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn __lgamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn tgamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn __tgamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn gamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn __gamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn lgamma_r(arg1: f64, __signgamp: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn __lgamma_r(arg1: f64, __signgamp: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn rint(__x: f64) -> f64;
}
extern "C" {
    pub fn __rint(__x: f64) -> f64;
}
extern "C" {
    pub fn nextafter(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __nextafter(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn nexttoward(__x: f64, __y: u128) -> f64;
}
extern "C" {
    pub fn __nexttoward(__x: f64, __y: u128) -> f64;
}
extern "C" {
    pub fn remainder(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __remainder(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn scalbn(__x: f64, __n: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn __scalbn(__x: f64, __n: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn ilogb(__x: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __ilogb(__x: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scalbln(__x: f64, __n: ::std::os::raw::c_long) -> f64;
}
extern "C" {
    pub fn __scalbln(__x: f64, __n: ::std::os::raw::c_long) -> f64;
}
extern "C" {
    pub fn nearbyint(__x: f64) -> f64;
}
extern "C" {
    pub fn __nearbyint(__x: f64) -> f64;
}
extern "C" {
    pub fn round(__x: f64) -> f64;
}
extern "C" {
    pub fn __round(__x: f64) -> f64;
}
extern "C" {
    pub fn trunc(__x: f64) -> f64;
}
extern "C" {
    pub fn __trunc(__x: f64) -> f64;
}
extern "C" {
    pub fn remquo(__x: f64, __y: f64, __quo: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn __remquo(__x: f64, __y: f64, __quo: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn lrint(__x: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn __lrint(__x: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llrint(__x: f64) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn __llrint(__x: f64) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn lround(__x: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn __lround(__x: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llround(__x: f64) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn __llround(__x: f64) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn fdim(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __fdim(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn fmax(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __fmax(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn fmin(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __fmin(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn fma(__x: f64, __y: f64, __z: f64) -> f64;
}
extern "C" {
    pub fn __fma(__x: f64, __y: f64, __z: f64) -> f64;
}
extern "C" {
    pub fn scalb(__x: f64, __n: f64) -> f64;
}
extern "C" {
    pub fn __scalb(__x: f64, __n: f64) -> f64;
}
extern "C" {
    pub fn __fpclassifyf(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __signbitf(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __isinff(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __finitef(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __isnanf(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __iseqsigf(__x: f32, __y: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __issignalingf(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acosf(__x: f32) -> f32;
}
extern "C" {
    pub fn __acosf(__x: f32) -> f32;
}
extern "C" {
    pub fn asinf(__x: f32) -> f32;
}
extern "C" {
    pub fn __asinf(__x: f32) -> f32;
}
extern "C" {
    pub fn atanf(__x: f32) -> f32;
}
extern "C" {
    pub fn __atanf(__x: f32) -> f32;
}
extern "C" {
    pub fn atan2f(__y: f32, __x: f32) -> f32;
}
extern "C" {
    pub fn __atan2f(__y: f32, __x: f32) -> f32;
}
extern "C" {
    pub fn cosf(__x: f32) -> f32;
}
extern "C" {
    pub fn __cosf(__x: f32) -> f32;
}
extern "C" {
    pub fn sinf(__x: f32) -> f32;
}
extern "C" {
    pub fn __sinf(__x: f32) -> f32;
}
extern "C" {
    pub fn tanf(__x: f32) -> f32;
}
extern "C" {
    pub fn __tanf(__x: f32) -> f32;
}
extern "C" {
    pub fn coshf(__x: f32) -> f32;
}
extern "C" {
    pub fn __coshf(__x: f32) -> f32;
}
extern "C" {
    pub fn sinhf(__x: f32) -> f32;
}
extern "C" {
    pub fn __sinhf(__x: f32) -> f32;
}
extern "C" {
    pub fn tanhf(__x: f32) -> f32;
}
extern "C" {
    pub fn __tanhf(__x: f32) -> f32;
}
extern "C" {
    pub fn acoshf(__x: f32) -> f32;
}
extern "C" {
    pub fn __acoshf(__x: f32) -> f32;
}
extern "C" {
    pub fn asinhf(__x: f32) -> f32;
}
extern "C" {
    pub fn __asinhf(__x: f32) -> f32;
}
extern "C" {
    pub fn atanhf(__x: f32) -> f32;
}
extern "C" {
    pub fn __atanhf(__x: f32) -> f32;
}
extern "C" {
    pub fn expf(__x: f32) -> f32;
}
extern "C" {
    pub fn __expf(__x: f32) -> f32;
}
extern "C" {
    pub fn frexpf(__x: f32, __exponent: *mut ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn __frexpf(__x: f32, __exponent: *mut ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn ldexpf(__x: f32, __exponent: ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn __ldexpf(__x: f32, __exponent: ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn logf(__x: f32) -> f32;
}
extern "C" {
    pub fn __logf(__x: f32) -> f32;
}
extern "C" {
    pub fn log10f(__x: f32) -> f32;
}
extern "C" {
    pub fn __log10f(__x: f32) -> f32;
}
extern "C" {
    pub fn modff(__x: f32, __iptr: *mut f32) -> f32;
}
extern "C" {
    pub fn __modff(__x: f32, __iptr: *mut f32) -> f32;
}
extern "C" {
    pub fn expm1f(__x: f32) -> f32;
}
extern "C" {
    pub fn __expm1f(__x: f32) -> f32;
}
extern "C" {
    pub fn log1pf(__x: f32) -> f32;
}
extern "C" {
    pub fn __log1pf(__x: f32) -> f32;
}
extern "C" {
    pub fn logbf(__x: f32) -> f32;
}
extern "C" {
    pub fn __logbf(__x: f32) -> f32;
}
extern "C" {
    pub fn exp2f(__x: f32) -> f32;
}
extern "C" {
    pub fn __exp2f(__x: f32) -> f32;
}
extern "C" {
    pub fn log2f(__x: f32) -> f32;
}
extern "C" {
    pub fn __log2f(__x: f32) -> f32;
}
extern "C" {
    pub fn powf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __powf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn sqrtf(__x: f32) -> f32;
}
extern "C" {
    pub fn __sqrtf(__x: f32) -> f32;
}
extern "C" {
    pub fn hypotf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __hypotf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn cbrtf(__x: f32) -> f32;
}
extern "C" {
    pub fn __cbrtf(__x: f32) -> f32;
}
extern "C" {
    pub fn ceilf(__x: f32) -> f32;
}
extern "C" {
    pub fn __ceilf(__x: f32) -> f32;
}
extern "C" {
    pub fn fabsf(__x: f32) -> f32;
}
extern "C" {
    pub fn __fabsf(__x: f32) -> f32;
}
extern "C" {
    pub fn floorf(__x: f32) -> f32;
}
extern "C" {
    pub fn __floorf(__x: f32) -> f32;
}
extern "C" {
    pub fn fmodf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __fmodf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn isinff(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn finitef(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dremf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __dremf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn significandf(__x: f32) -> f32;
}
extern "C" {
    pub fn __significandf(__x: f32) -> f32;
}
extern "C" {
    pub fn copysignf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __copysignf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn nanf(__tagb: *const ::std::os::raw::c_char) -> f32;
}
extern "C" {
    pub fn __nanf(__tagb: *const ::std::os::raw::c_char) -> f32;
}
extern "C" {
    pub fn isnanf(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn j0f(arg1: f32) -> f32;
}
extern "C" {
    pub fn __j0f(arg1: f32) -> f32;
}
extern "C" {
    pub fn j1f(arg1: f32) -> f32;
}
extern "C" {
    pub fn __j1f(arg1: f32) -> f32;
}
extern "C" {
    pub fn jnf(arg1: ::std::os::raw::c_int, arg2: f32) -> f32;
}
extern "C" {
    pub fn __jnf(arg1: ::std::os::raw::c_int, arg2: f32) -> f32;
}
extern "C" {
    pub fn y0f(arg1: f32) -> f32;
}
extern "C" {
    pub fn __y0f(arg1: f32) -> f32;
}
extern "C" {
    pub fn y1f(arg1: f32) -> f32;
}
extern "C" {
    pub fn __y1f(arg1: f32) -> f32;
}
extern "C" {
    pub fn ynf(arg1: ::std::os::raw::c_int, arg2: f32) -> f32;
}
extern "C" {
    pub fn __ynf(arg1: ::std::os::raw::c_int, arg2: f32) -> f32;
}
extern "C" {
    pub fn erff(arg1: f32) -> f32;
}
extern "C" {
    pub fn __erff(arg1: f32) -> f32;
}
extern "C" {
    pub fn erfcf(arg1: f32) -> f32;
}
extern "C" {
    pub fn __erfcf(arg1: f32) -> f32;
}
extern "C" {
    pub fn lgammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn __lgammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn tgammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn __tgammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn gammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn __gammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn lgammaf_r(arg1: f32, __signgamp: *mut ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn __lgammaf_r(arg1: f32, __signgamp: *mut ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn rintf(__x: f32) -> f32;
}
extern "C" {
    pub fn __rintf(__x: f32) -> f32;
}
extern "C" {
    pub fn nextafterf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __nextafterf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn nexttowardf(__x: f32, __y: u128) -> f32;
}
extern "C" {
    pub fn __nexttowardf(__x: f32, __y: u128) -> f32;
}
extern "C" {
    pub fn remainderf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __remainderf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn scalbnf(__x: f32, __n: ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn __scalbnf(__x: f32, __n: ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn ilogbf(__x: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __ilogbf(__x: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scalblnf(__x: f32, __n: ::std::os::raw::c_long) -> f32;
}
extern "C" {
    pub fn __scalblnf(__x: f32, __n: ::std::os::raw::c_long) -> f32;
}
extern "C" {
    pub fn nearbyintf(__x: f32) -> f32;
}
extern "C" {
    pub fn __nearbyintf(__x: f32) -> f32;
}
extern "C" {
    pub fn roundf(__x: f32) -> f32;
}
extern "C" {
    pub fn __roundf(__x: f32) -> f32;
}
extern "C" {
    pub fn truncf(__x: f32) -> f32;
}
extern "C" {
    pub fn __truncf(__x: f32) -> f32;
}
extern "C" {
    pub fn remquof(__x: f32, __y: f32, __quo: *mut ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn __remquof(__x: f32, __y: f32, __quo: *mut ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn lrintf(__x: f32) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn __lrintf(__x: f32) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llrintf(__x: f32) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn __llrintf(__x: f32) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn lroundf(__x: f32) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn __lroundf(__x: f32) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llroundf(__x: f32) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn __llroundf(__x: f32) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn fdimf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __fdimf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn fmaxf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __fmaxf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn fminf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __fminf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn fmaf(__x: f32, __y: f32, __z: f32) -> f32;
}
extern "C" {
    pub fn __fmaf(__x: f32, __y: f32, __z: f32) -> f32;
}
extern "C" {
    pub fn scalbf(__x: f32, __n: f32) -> f32;
}
extern "C" {
    pub fn __scalbf(__x: f32, __n: f32) -> f32;
}
extern "C" {
    pub fn __fpclassifyl(__value: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __signbitl(__value: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __isinfl(__value: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __finitel(__value: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __isnanl(__value: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __iseqsigl(__x: u128, __y: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __issignalingl(__value: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acosl(__x: u128) -> u128;
}
extern "C" {
    pub fn __acosl(__x: u128) -> u128;
}
extern "C" {
    pub fn asinl(__x: u128) -> u128;
}
extern "C" {
    pub fn __asinl(__x: u128) -> u128;
}
extern "C" {
    pub fn atanl(__x: u128) -> u128;
}
extern "C" {
    pub fn __atanl(__x: u128) -> u128;
}
extern "C" {
    pub fn atan2l(__y: u128, __x: u128) -> u128;
}
extern "C" {
    pub fn __atan2l(__y: u128, __x: u128) -> u128;
}
extern "C" {
    pub fn cosl(__x: u128) -> u128;
}
extern "C" {
    pub fn __cosl(__x: u128) -> u128;
}
extern "C" {
    pub fn sinl(__x: u128) -> u128;
}
extern "C" {
    pub fn __sinl(__x: u128) -> u128;
}
extern "C" {
    pub fn tanl(__x: u128) -> u128;
}
extern "C" {
    pub fn __tanl(__x: u128) -> u128;
}
extern "C" {
    pub fn coshl(__x: u128) -> u128;
}
extern "C" {
    pub fn __coshl(__x: u128) -> u128;
}
extern "C" {
    pub fn sinhl(__x: u128) -> u128;
}
extern "C" {
    pub fn __sinhl(__x: u128) -> u128;
}
extern "C" {
    pub fn tanhl(__x: u128) -> u128;
}
extern "C" {
    pub fn __tanhl(__x: u128) -> u128;
}
extern "C" {
    pub fn acoshl(__x: u128) -> u128;
}
extern "C" {
    pub fn __acoshl(__x: u128) -> u128;
}
extern "C" {
    pub fn asinhl(__x: u128) -> u128;
}
extern "C" {
    pub fn __asinhl(__x: u128) -> u128;
}
extern "C" {
    pub fn atanhl(__x: u128) -> u128;
}
extern "C" {
    pub fn __atanhl(__x: u128) -> u128;
}
extern "C" {
    pub fn expl(__x: u128) -> u128;
}
extern "C" {
    pub fn __expl(__x: u128) -> u128;
}
extern "C" {
    pub fn frexpl(__x: u128, __exponent: *mut ::std::os::raw::c_int) -> u128;
}
extern "C" {
    pub fn __frexpl(__x: u128, __exponent: *mut ::std::os::raw::c_int) -> u128;
}
extern "C" {
    pub fn ldexpl(__x: u128, __exponent: ::std::os::raw::c_int) -> u128;
}
extern "C" {
    pub fn __ldexpl(__x: u128, __exponent: ::std::os::raw::c_int) -> u128;
}
extern "C" {
    pub fn logl(__x: u128) -> u128;
}
extern "C" {
    pub fn __logl(__x: u128) -> u128;
}
extern "C" {
    pub fn log10l(__x: u128) -> u128;
}
extern "C" {
    pub fn __log10l(__x: u128) -> u128;
}
extern "C" {
    pub fn modfl(__x: u128, __iptr: *mut u128) -> u128;
}
extern "C" {
    pub fn __modfl(__x: u128, __iptr: *mut u128) -> u128;
}
extern "C" {
    pub fn expm1l(__x: u128) -> u128;
}
extern "C" {
    pub fn __expm1l(__x: u128) -> u128;
}
extern "C" {
    pub fn log1pl(__x: u128) -> u128;
}
extern "C" {
    pub fn __log1pl(__x: u128) -> u128;
}
extern "C" {
    pub fn logbl(__x: u128) -> u128;
}
extern "C" {
    pub fn __logbl(__x: u128) -> u128;
}
extern "C" {
    pub fn exp2l(__x: u128) -> u128;
}
extern "C" {
    pub fn __exp2l(__x: u128) -> u128;
}
extern "C" {
    pub fn log2l(__x: u128) -> u128;
}
extern "C" {
    pub fn __log2l(__x: u128) -> u128;
}
extern "C" {
    pub fn powl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn __powl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn sqrtl(__x: u128) -> u128;
}
extern "C" {
    pub fn __sqrtl(__x: u128) -> u128;
}
extern "C" {
    pub fn hypotl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn __hypotl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn cbrtl(__x: u128) -> u128;
}
extern "C" {
    pub fn __cbrtl(__x: u128) -> u128;
}
extern "C" {
    pub fn ceill(__x: u128) -> u128;
}
extern "C" {
    pub fn __ceill(__x: u128) -> u128;
}
extern "C" {
    pub fn fabsl(__x: u128) -> u128;
}
extern "C" {
    pub fn __fabsl(__x: u128) -> u128;
}
extern "C" {
    pub fn floorl(__x: u128) -> u128;
}
extern "C" {
    pub fn __floorl(__x: u128) -> u128;
}
extern "C" {
    pub fn fmodl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn __fmodl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn isinfl(__value: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn finitel(__value: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dreml(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn __dreml(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn significandl(__x: u128) -> u128;
}
extern "C" {
    pub fn __significandl(__x: u128) -> u128;
}
extern "C" {
    pub fn copysignl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn __copysignl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn nanl(__tagb: *const ::std::os::raw::c_char) -> u128;
}
extern "C" {
    pub fn __nanl(__tagb: *const ::std::os::raw::c_char) -> u128;
}
extern "C" {
    pub fn isnanl(__value: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn j0l(arg1: u128) -> u128;
}
extern "C" {
    pub fn __j0l(arg1: u128) -> u128;
}
extern "C" {
    pub fn j1l(arg1: u128) -> u128;
}
extern "C" {
    pub fn __j1l(arg1: u128) -> u128;
}
extern "C" {
    pub fn jnl(arg1: ::std::os::raw::c_int, arg2: u128) -> u128;
}
extern "C" {
    pub fn __jnl(arg1: ::std::os::raw::c_int, arg2: u128) -> u128;
}
extern "C" {
    pub fn y0l(arg1: u128) -> u128;
}
extern "C" {
    pub fn __y0l(arg1: u128) -> u128;
}
extern "C" {
    pub fn y1l(arg1: u128) -> u128;
}
extern "C" {
    pub fn __y1l(arg1: u128) -> u128;
}
extern "C" {
    pub fn ynl(arg1: ::std::os::raw::c_int, arg2: u128) -> u128;
}
extern "C" {
    pub fn __ynl(arg1: ::std::os::raw::c_int, arg2: u128) -> u128;
}
extern "C" {
    pub fn erfl(arg1: u128) -> u128;
}
extern "C" {
    pub fn __erfl(arg1: u128) -> u128;
}
extern "C" {
    pub fn erfcl(arg1: u128) -> u128;
}
extern "C" {
    pub fn __erfcl(arg1: u128) -> u128;
}
extern "C" {
    pub fn lgammal(arg1: u128) -> u128;
}
extern "C" {
    pub fn __lgammal(arg1: u128) -> u128;
}
extern "C" {
    pub fn tgammal(arg1: u128) -> u128;
}
extern "C" {
    pub fn __tgammal(arg1: u128) -> u128;
}
extern "C" {
    pub fn gammal(arg1: u128) -> u128;
}
extern "C" {
    pub fn __gammal(arg1: u128) -> u128;
}
extern "C" {
    pub fn lgammal_r(arg1: u128, __signgamp: *mut ::std::os::raw::c_int) -> u128;
}
extern "C" {
    pub fn __lgammal_r(arg1: u128, __signgamp: *mut ::std::os::raw::c_int) -> u128;
}
extern "C" {
    pub fn rintl(__x: u128) -> u128;
}
extern "C" {
    pub fn __rintl(__x: u128) -> u128;
}
extern "C" {
    pub fn nextafterl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn __nextafterl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn nexttowardl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn __nexttowardl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn remainderl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn __remainderl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn scalbnl(__x: u128, __n: ::std::os::raw::c_int) -> u128;
}
extern "C" {
    pub fn __scalbnl(__x: u128, __n: ::std::os::raw::c_int) -> u128;
}
extern "C" {
    pub fn ilogbl(__x: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __ilogbl(__x: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scalblnl(__x: u128, __n: ::std::os::raw::c_long) -> u128;
}
extern "C" {
    pub fn __scalblnl(__x: u128, __n: ::std::os::raw::c_long) -> u128;
}
extern "C" {
    pub fn nearbyintl(__x: u128) -> u128;
}
extern "C" {
    pub fn __nearbyintl(__x: u128) -> u128;
}
extern "C" {
    pub fn roundl(__x: u128) -> u128;
}
extern "C" {
    pub fn __roundl(__x: u128) -> u128;
}
extern "C" {
    pub fn truncl(__x: u128) -> u128;
}
extern "C" {
    pub fn __truncl(__x: u128) -> u128;
}
extern "C" {
    pub fn remquol(__x: u128, __y: u128, __quo: *mut ::std::os::raw::c_int) -> u128;
}
extern "C" {
    pub fn __remquol(__x: u128, __y: u128, __quo: *mut ::std::os::raw::c_int) -> u128;
}
extern "C" {
    pub fn lrintl(__x: u128) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn __lrintl(__x: u128) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llrintl(__x: u128) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn __llrintl(__x: u128) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn lroundl(__x: u128) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn __lroundl(__x: u128) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llroundl(__x: u128) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn __llroundl(__x: u128) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn fdiml(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn __fdiml(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn fmaxl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn __fmaxl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn fminl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn __fminl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn fmal(__x: u128, __y: u128, __z: u128) -> u128;
}
extern "C" {
    pub fn __fmal(__x: u128, __y: u128, __z: u128) -> u128;
}
extern "C" {
    pub fn scalbl(__x: u128, __n: u128) -> u128;
}
extern "C" {
    pub fn __scalbl(__x: u128, __n: u128) -> u128;
}
extern "C" {
    pub static mut signgam: ::std::os::raw::c_int;
}
pub const FP_NAN: _bindgen_ty_1 = 0;
pub const FP_INFINITE: _bindgen_ty_1 = 1;
pub const FP_ZERO: _bindgen_ty_1 = 2;
pub const FP_SUBNORMAL: _bindgen_ty_1 = 3;
pub const FP_NORMAL: _bindgen_ty_1 = 4;
pub type _bindgen_ty_1 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialOrd, PartialEq)]
pub struct PerlinNoise {
    pub d: [u8; 257usize],
    pub h2: u8,
    pub a: f64,
    pub b: f64,
    pub c: f64,
    pub amplitude: f64,
    pub lacunarity: f64,
    pub d2: f64,
    pub t2: f64,
}
#[test]
fn bindgen_test_layout_PerlinNoise() {
    const UNINIT: ::std::mem::MaybeUninit<PerlinNoise> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<PerlinNoise>(),
        320usize,
        concat!("Size of: ", stringify!(PerlinNoise))
    );
    assert_eq!(
        ::std::mem::align_of::<PerlinNoise>(),
        8usize,
        concat!("Alignment of ", stringify!(PerlinNoise))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).d) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PerlinNoise),
            "::",
            stringify!(d)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).h2) as usize - ptr as usize },
        257usize,
        concat!(
            "Offset of field: ",
            stringify!(PerlinNoise),
            "::",
            stringify!(h2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).a) as usize - ptr as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(PerlinNoise),
            "::",
            stringify!(a)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).b) as usize - ptr as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(PerlinNoise),
            "::",
            stringify!(b)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).c) as usize - ptr as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(PerlinNoise),
            "::",
            stringify!(c)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).amplitude) as usize - ptr as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(PerlinNoise),
            "::",
            stringify!(amplitude)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lacunarity) as usize - ptr as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(PerlinNoise),
            "::",
            stringify!(lacunarity)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).d2) as usize - ptr as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(PerlinNoise),
            "::",
            stringify!(d2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).t2) as usize - ptr as usize },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(PerlinNoise),
            "::",
            stringify!(t2)
        )
    );
}
impl Default for PerlinNoise {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct OctaveNoise {
    pub octcnt: ::std::os::raw::c_int,
    pub octaves: *mut PerlinNoise,
}
#[test]
fn bindgen_test_layout_OctaveNoise() {
    const UNINIT: ::std::mem::MaybeUninit<OctaveNoise> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<OctaveNoise>(),
        16usize,
        concat!("Size of: ", stringify!(OctaveNoise))
    );
    assert_eq!(
        ::std::mem::align_of::<OctaveNoise>(),
        8usize,
        concat!("Alignment of ", stringify!(OctaveNoise))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).octcnt) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OctaveNoise),
            "::",
            stringify!(octcnt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).octaves) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(OctaveNoise),
            "::",
            stringify!(octaves)
        )
    );
}
impl Default for OctaveNoise {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialOrd, PartialEq)]
pub struct DoublePerlinNoise {
    pub amplitude: f64,
    pub octA: OctaveNoise,
    pub octB: OctaveNoise,
}
#[test]
fn bindgen_test_layout_DoublePerlinNoise() {
    const UNINIT: ::std::mem::MaybeUninit<DoublePerlinNoise> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<DoublePerlinNoise>(),
        40usize,
        concat!("Size of: ", stringify!(DoublePerlinNoise))
    );
    assert_eq!(
        ::std::mem::align_of::<DoublePerlinNoise>(),
        8usize,
        concat!("Alignment of ", stringify!(DoublePerlinNoise))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).amplitude) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DoublePerlinNoise),
            "::",
            stringify!(amplitude)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).octA) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(DoublePerlinNoise),
            "::",
            stringify!(octA)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).octB) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(DoublePerlinNoise),
            "::",
            stringify!(octB)
        )
    );
}
impl Default for DoublePerlinNoise {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " Perlin noise"]
    pub fn perlinInit(noise: *mut PerlinNoise, seed: *mut u64);
}
extern "C" {
    pub fn xPerlinInit(noise: *mut PerlinNoise, xr: *mut Xoroshiro);
}
extern "C" {
    pub fn samplePerlin(
        noise: *const PerlinNoise,
        x: f64,
        y: f64,
        z: f64,
        yamp: f64,
        ymin: f64,
    ) -> f64;
}
extern "C" {
    pub fn sampleSimplex2D(noise: *const PerlinNoise, x: f64, y: f64) -> f64;
}
extern "C" {
    #[doc = " Perlin Octaves"]
    pub fn octaveInit(
        noise: *mut OctaveNoise,
        seed: *mut u64,
        octaves: *mut PerlinNoise,
        omin: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn octaveInitBeta(
        noise: *mut OctaveNoise,
        seed: *mut u64,
        octaves: *mut PerlinNoise,
        octcnt: ::std::os::raw::c_int,
        lac: f64,
        lacMul: f64,
        persist: f64,
        persistMul: f64,
    );
}
extern "C" {
    pub fn xOctaveInit(
        noise: *mut OctaveNoise,
        xr: *mut Xoroshiro,
        octaves: *mut PerlinNoise,
        amplitudes: *const f64,
        omin: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
        nmax: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sampleOctave(noise: *const OctaveNoise, x: f64, y: f64, z: f64) -> f64;
}
extern "C" {
    pub fn sampleOctaveAmp(
        noise: *const OctaveNoise,
        x: f64,
        y: f64,
        z: f64,
        yamp: f64,
        ymin: f64,
        ydefault: ::std::os::raw::c_int,
    ) -> f64;
}
extern "C" {
    pub fn sampleOctave2D(noise: *const OctaveNoise, x: f64, z: f64) -> f64;
}
extern "C" {
    pub fn sampleOctaveBeta17Biome(noise: *const OctaveNoise, x: f64, z: f64) -> f64;
}
extern "C" {
    pub fn sampleOctaveBeta17Terrain(
        noise: *const OctaveNoise,
        v: *mut f64,
        x: f64,
        z: f64,
        yLacFlag: ::std::os::raw::c_int,
        lacmin: f64,
    );
}
extern "C" {
    #[doc = " Double Perlin"]
    pub fn doublePerlinInit(
        noise: *mut DoublePerlinNoise,
        seed: *mut u64,
        octavesA: *mut PerlinNoise,
        octavesB: *mut PerlinNoise,
        omin: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn xDoublePerlinInit(
        noise: *mut DoublePerlinNoise,
        xr: *mut Xoroshiro,
        octaves: *mut PerlinNoise,
        amplitudes: *const f64,
        omin: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
        nmax: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sampleDoublePerlin(noise: *const DoublePerlinNoise, x: f64, y: f64, z: f64) -> f64;
}
pub const BiomeTempCategory_Oceanic: BiomeTempCategory = 0;
pub const BiomeTempCategory_Warm: BiomeTempCategory = 1;
pub const BiomeTempCategory_Lush: BiomeTempCategory = 2;
pub const BiomeTempCategory_Cold: BiomeTempCategory = 3;
pub const BiomeTempCategory_Freezing: BiomeTempCategory = 4;
pub const BiomeTempCategory_Special: BiomeTempCategory = 5;
pub type BiomeTempCategory = ::std::os::raw::c_uint;
pub const LayerId_L_CONTINENT_4096: LayerId = 0;
pub const LayerId_L_ISLAND_4096: LayerId = 0;
pub const LayerId_L_ZOOM_4096: LayerId = 1;
pub const LayerId_L_LAND_4096: LayerId = 2;
pub const LayerId_L_ZOOM_2048: LayerId = 3;
pub const LayerId_L_LAND_2048: LayerId = 4;
pub const LayerId_L_ADD_ISLAND_2048: LayerId = 4;
pub const LayerId_L_ZOOM_1024: LayerId = 5;
pub const LayerId_L_LAND_1024_A: LayerId = 6;
pub const LayerId_L_ADD_ISLAND_1024A: LayerId = 6;
pub const LayerId_L_LAND_1024_B: LayerId = 7;
pub const LayerId_L_ADD_ISLAND_1024B: LayerId = 7;
pub const LayerId_L_LAND_1024_C: LayerId = 8;
pub const LayerId_L_ADD_ISLAND_1024C: LayerId = 8;
pub const LayerId_L_ISLAND_1024: LayerId = 9;
pub const LayerId_L_REMOVE_OCEAN_1024: LayerId = 9;
pub const LayerId_L_SNOW_1024: LayerId = 10;
pub const LayerId_L_ADD_SNOW_1024: LayerId = 10;
pub const LayerId_L_LAND_1024_D: LayerId = 11;
pub const LayerId_L_ADD_ISLAND_1024D: LayerId = 11;
pub const LayerId_L_COOL_1024: LayerId = 12;
pub const LayerId_L_COOL_WARM_1024: LayerId = 12;
pub const LayerId_L_HEAT_1024: LayerId = 13;
pub const LayerId_L_HEAT_ICE_1024: LayerId = 13;
pub const LayerId_L_SPECIAL_1024: LayerId = 14;
pub const LayerId_L_ZOOM_512: LayerId = 15;
pub const LayerId_L_LAND_512: LayerId = 16;
pub const LayerId_L_ZOOM_256: LayerId = 17;
pub const LayerId_L_LAND_256: LayerId = 18;
pub const LayerId_L_ADD_ISLAND_256: LayerId = 18;
pub const LayerId_L_MUSHROOM_256: LayerId = 19;
pub const LayerId_L_ADD_MUSHROOM_256: LayerId = 19;
pub const LayerId_L_DEEP_OCEAN_256: LayerId = 20;
pub const LayerId_L_BIOME_256: LayerId = 21;
pub const LayerId_L_BAMBOO_256: LayerId = 22;
pub const LayerId_L14_BAMBOO_256: LayerId = 22;
pub const LayerId_L_ZOOM_128: LayerId = 23;
pub const LayerId_L_ZOOM_64: LayerId = 24;
pub const LayerId_L_BIOME_EDGE_64: LayerId = 25;
pub const LayerId_L_NOISE_256: LayerId = 26;
pub const LayerId_L_RIVER_INIT_256: LayerId = 26;
pub const LayerId_L_ZOOM_128_HILLS: LayerId = 27;
pub const LayerId_L_ZOOM_64_HILLS: LayerId = 28;
pub const LayerId_L_HILLS_64: LayerId = 29;
pub const LayerId_L_SUNFLOWER_64: LayerId = 30;
pub const LayerId_L_RARE_BIOME_64: LayerId = 30;
pub const LayerId_L_ZOOM_32: LayerId = 31;
pub const LayerId_L_LAND_32: LayerId = 32;
pub const LayerId_L_ADD_ISLAND_32: LayerId = 32;
pub const LayerId_L_ZOOM_16: LayerId = 33;
pub const LayerId_L_SHORE_16: LayerId = 34;
pub const LayerId_L_SWAMP_RIVER_16: LayerId = 35;
pub const LayerId_L_ZOOM_8: LayerId = 36;
pub const LayerId_L_ZOOM_4: LayerId = 37;
pub const LayerId_L_SMOOTH_4: LayerId = 38;
pub const LayerId_L_ZOOM_128_RIVER: LayerId = 39;
pub const LayerId_L_ZOOM_64_RIVER: LayerId = 40;
pub const LayerId_L_ZOOM_32_RIVER: LayerId = 41;
pub const LayerId_L_ZOOM_16_RIVER: LayerId = 42;
pub const LayerId_L_ZOOM_8_RIVER: LayerId = 43;
pub const LayerId_L_ZOOM_4_RIVER: LayerId = 44;
pub const LayerId_L_RIVER_4: LayerId = 45;
pub const LayerId_L_SMOOTH_4_RIVER: LayerId = 46;
pub const LayerId_L_RIVER_MIX_4: LayerId = 47;
pub const LayerId_L_OCEAN_TEMP_256: LayerId = 48;
pub const LayerId_L13_OCEAN_TEMP_256: LayerId = 48;
pub const LayerId_L_ZOOM_128_OCEAN: LayerId = 49;
pub const LayerId_L13_ZOOM_128: LayerId = 49;
pub const LayerId_L_ZOOM_64_OCEAN: LayerId = 50;
pub const LayerId_L13_ZOOM_64: LayerId = 50;
pub const LayerId_L_ZOOM_32_OCEAN: LayerId = 51;
pub const LayerId_L13_ZOOM_32: LayerId = 51;
pub const LayerId_L_ZOOM_16_OCEAN: LayerId = 52;
pub const LayerId_L13_ZOOM_16: LayerId = 52;
pub const LayerId_L_ZOOM_8_OCEAN: LayerId = 53;
pub const LayerId_L13_ZOOM_8: LayerId = 53;
pub const LayerId_L_ZOOM_4_OCEAN: LayerId = 54;
pub const LayerId_L13_ZOOM_4: LayerId = 54;
pub const LayerId_L_OCEAN_MIX_4: LayerId = 55;
pub const LayerId_L13_OCEAN_MIX_4: LayerId = 55;
pub const LayerId_L_VORONOI_1: LayerId = 56;
pub const LayerId_L_VORONOI_ZOOM_1: LayerId = 56;
pub const LayerId_L_ZOOM_LARGE_A: LayerId = 57;
pub const LayerId_L_ZOOM_LARGE_B: LayerId = 58;
pub const LayerId_L_ZOOM_L_RIVER_A: LayerId = 59;
pub const LayerId_L_ZOOM_L_RIVER_B: LayerId = 60;
pub const LayerId_L_NUM: LayerId = 61;
pub type LayerId = ::std::os::raw::c_uint;
pub type mapfunc_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const Layer,
        arg2: *mut ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::os::raw::c_int,
        arg5: ::std::os::raw::c_int,
        arg6: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct Layer {
    pub getMap: mapfunc_t,
    pub mc: i8,
    pub zoom: i8,
    pub edge: i8,
    pub scale: ::std::os::raw::c_int,
    pub layerSalt: u64,
    pub startSalt: u64,
    pub startSeed: u64,
    pub noise: *mut ::std::os::raw::c_void,
    pub data: *mut ::std::os::raw::c_void,
    pub p: *mut Layer,
    pub p2: *mut Layer,
}
#[test]
fn bindgen_test_layout_Layer() {
    const UNINIT: ::std::mem::MaybeUninit<Layer> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Layer>(),
        72usize,
        concat!("Size of: ", stringify!(Layer))
    );
    assert_eq!(
        ::std::mem::align_of::<Layer>(),
        8usize,
        concat!("Alignment of ", stringify!(Layer))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).getMap) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Layer),
            "::",
            stringify!(getMap)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mc) as usize - ptr as usize },
        8usize,
        concat!("Offset of field: ", stringify!(Layer), "::", stringify!(mc))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).zoom) as usize - ptr as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(Layer),
            "::",
            stringify!(zoom)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).edge) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(Layer),
            "::",
            stringify!(edge)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).scale) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(Layer),
            "::",
            stringify!(scale)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).layerSalt) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Layer),
            "::",
            stringify!(layerSalt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).startSalt) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(Layer),
            "::",
            stringify!(startSalt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).startSeed) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(Layer),
            "::",
            stringify!(startSeed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).noise) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(Layer),
            "::",
            stringify!(noise)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(Layer),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).p) as usize - ptr as usize },
        56usize,
        concat!("Offset of field: ", stringify!(Layer), "::", stringify!(p))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).p2) as usize - ptr as usize },
        64usize,
        concat!("Offset of field: ", stringify!(Layer), "::", stringify!(p2))
    );
}
impl Default for Layer {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialOrd, PartialEq)]
pub struct LayerStack {
    pub layers: [Layer; 61usize],
    pub entry_1: *mut Layer,
    pub entry_4: *mut Layer,
    pub entry_16: *mut Layer,
    pub entry_64: *mut Layer,
    pub entry_256: *mut Layer,
    pub oceanRnd: PerlinNoise,
}
#[test]
fn bindgen_test_layout_LayerStack() {
    const UNINIT: ::std::mem::MaybeUninit<LayerStack> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<LayerStack>(),
        4752usize,
        concat!("Size of: ", stringify!(LayerStack))
    );
    assert_eq!(
        ::std::mem::align_of::<LayerStack>(),
        8usize,
        concat!("Alignment of ", stringify!(LayerStack))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).layers) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LayerStack),
            "::",
            stringify!(layers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).entry_1) as usize - ptr as usize },
        4392usize,
        concat!(
            "Offset of field: ",
            stringify!(LayerStack),
            "::",
            stringify!(entry_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).entry_4) as usize - ptr as usize },
        4400usize,
        concat!(
            "Offset of field: ",
            stringify!(LayerStack),
            "::",
            stringify!(entry_4)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).entry_16) as usize - ptr as usize },
        4408usize,
        concat!(
            "Offset of field: ",
            stringify!(LayerStack),
            "::",
            stringify!(entry_16)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).entry_64) as usize - ptr as usize },
        4416usize,
        concat!(
            "Offset of field: ",
            stringify!(LayerStack),
            "::",
            stringify!(entry_64)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).entry_256) as usize - ptr as usize },
        4424usize,
        concat!(
            "Offset of field: ",
            stringify!(LayerStack),
            "::",
            stringify!(entry_256)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).oceanRnd) as usize - ptr as usize },
        4432usize,
        concat!(
            "Offset of field: ",
            stringify!(LayerStack),
            "::",
            stringify!(oceanRnd)
        )
    );
}
impl Default for LayerStack {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn biomeExists(
        mc: ::std::os::raw::c_int,
        id: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isOverworld(
        mc: ::std::os::raw::c_int,
        id: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getDimension(id: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getMutated(
        mc: ::std::os::raw::c_int,
        id: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getCategory(
        mc: ::std::os::raw::c_int,
        id: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn areSimilar(
        mc: ::std::os::raw::c_int,
        id1: ::std::os::raw::c_int,
        id2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isMesa(id: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isShallowOcean(id: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isDeepOcean(id: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isOceanic(id: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isSnowy(id: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getBiomeDepthAndScale(
        id: ::std::os::raw::c_int,
        depth: *mut f64,
        scale: *mut f64,
        grass: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setLayerSeed(layer: *mut Layer, worldSeed: u64);
}
extern "C" {
    pub fn mapContinent(
        arg1: *const Layer,
        arg2: *mut ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::os::raw::c_int,
        arg5: ::std::os::raw::c_int,
        arg6: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mapZoomFuzzy(
        arg1: *const Layer,
        arg2: *mut ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::os::raw::c_int,
        arg5: ::std::os::raw::c_int,
        arg6: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mapZoom(
        arg1: *const Layer,
        arg2: *mut ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::os::raw::c_int,
        arg5: ::std::os::raw::c_int,
        arg6: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mapLand(
        arg1: *const Layer,
        arg2: *mut ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::os::raw::c_int,
        arg5: ::std::os::raw::c_int,
        arg6: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mapLand16(
        arg1: *const Layer,
        arg2: *mut ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::os::raw::c_int,
        arg5: ::std::os::raw::c_int,
        arg6: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mapLandB18(
        arg1: *const Layer,
        arg2: *mut ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::os::raw::c_int,
        arg5: ::std::os::raw::c_int,
        arg6: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mapIsland(
        arg1: *const Layer,
        arg2: *mut ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::os::raw::c_int,
        arg5: ::std::os::raw::c_int,
        arg6: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mapSnow(
        arg1: *const Layer,
        arg2: *mut ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::os::raw::c_int,
        arg5: ::std::os::raw::c_int,
        arg6: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mapSnow16(
        arg1: *const Layer,
        arg2: *mut ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::os::raw::c_int,
        arg5: ::std::os::raw::c_int,
        arg6: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mapCool(
        arg1: *const Layer,
        arg2: *mut ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::os::raw::c_int,
        arg5: ::std::os::raw::c_int,
        arg6: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mapHeat(
        arg1: *const Layer,
        arg2: *mut ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::os::raw::c_int,
        arg5: ::std::os::raw::c_int,
        arg6: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mapSpecial(
        arg1: *const Layer,
        arg2: *mut ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::os::raw::c_int,
        arg5: ::std::os::raw::c_int,
        arg6: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mapMushroom(
        arg1: *const Layer,
        arg2: *mut ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::os::raw::c_int,
        arg5: ::std::os::raw::c_int,
        arg6: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mapDeepOcean(
        arg1: *const Layer,
        arg2: *mut ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::os::raw::c_int,
        arg5: ::std::os::raw::c_int,
        arg6: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mapBiome(
        arg1: *const Layer,
        arg2: *mut ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::os::raw::c_int,
        arg5: ::std::os::raw::c_int,
        arg6: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mapBamboo(
        arg1: *const Layer,
        arg2: *mut ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::os::raw::c_int,
        arg5: ::std::os::raw::c_int,
        arg6: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mapNoise(
        arg1: *const Layer,
        arg2: *mut ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::os::raw::c_int,
        arg5: ::std::os::raw::c_int,
        arg6: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mapBiomeEdge(
        arg1: *const Layer,
        arg2: *mut ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::os::raw::c_int,
        arg5: ::std::os::raw::c_int,
        arg6: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mapHills(
        arg1: *const Layer,
        arg2: *mut ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::os::raw::c_int,
        arg5: ::std::os::raw::c_int,
        arg6: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mapRiver(
        arg1: *const Layer,
        arg2: *mut ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::os::raw::c_int,
        arg5: ::std::os::raw::c_int,
        arg6: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mapSmooth(
        arg1: *const Layer,
        arg2: *mut ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::os::raw::c_int,
        arg5: ::std::os::raw::c_int,
        arg6: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mapSunflower(
        arg1: *const Layer,
        arg2: *mut ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::os::raw::c_int,
        arg5: ::std::os::raw::c_int,
        arg6: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mapShore(
        arg1: *const Layer,
        arg2: *mut ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::os::raw::c_int,
        arg5: ::std::os::raw::c_int,
        arg6: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mapSwampRiver(
        arg1: *const Layer,
        arg2: *mut ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::os::raw::c_int,
        arg5: ::std::os::raw::c_int,
        arg6: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mapRiverMix(
        arg1: *const Layer,
        arg2: *mut ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::os::raw::c_int,
        arg5: ::std::os::raw::c_int,
        arg6: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mapOceanTemp(
        arg1: *const Layer,
        arg2: *mut ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::os::raw::c_int,
        arg5: ::std::os::raw::c_int,
        arg6: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mapOceanMix(
        arg1: *const Layer,
        arg2: *mut ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::os::raw::c_int,
        arg5: ::std::os::raw::c_int,
        arg6: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mapVoronoi(
        arg1: *const Layer,
        arg2: *mut ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::os::raw::c_int,
        arg5: ::std::os::raw::c_int,
        arg6: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mapVoronoi114(
        arg1: *const Layer,
        arg2: *mut ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::os::raw::c_int,
        arg5: ::std::os::raw::c_int,
        arg6: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getVoronoiSHA(worldSeed: u64) -> u64;
}
extern "C" {
    pub fn voronoiAccess3D(
        sha: u64,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
        z: ::std::os::raw::c_int,
        x4: *mut ::std::os::raw::c_int,
        y4: *mut ::std::os::raw::c_int,
        z4: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn mapVoronoiPlane(
        sha: u64,
        out: *mut ::std::os::raw::c_int,
        src: *mut ::std::os::raw::c_int,
        x: ::std::os::raw::c_int,
        z: ::std::os::raw::c_int,
        w: ::std::os::raw::c_int,
        h: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
        px: ::std::os::raw::c_int,
        pz: ::std::os::raw::c_int,
        pw: ::std::os::raw::c_int,
        ph: ::std::os::raw::c_int,
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct Range {
    pub scale: ::std::os::raw::c_int,
    pub x: ::std::os::raw::c_int,
    pub z: ::std::os::raw::c_int,
    pub sx: ::std::os::raw::c_int,
    pub sz: ::std::os::raw::c_int,
    pub y: ::std::os::raw::c_int,
    pub sy: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_Range() {
    const UNINIT: ::std::mem::MaybeUninit<Range> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Range>(),
        28usize,
        concat!("Size of: ", stringify!(Range))
    );
    assert_eq!(
        ::std::mem::align_of::<Range>(),
        4usize,
        concat!("Alignment of ", stringify!(Range))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).scale) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Range),
            "::",
            stringify!(scale)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        4usize,
        concat!("Offset of field: ", stringify!(Range), "::", stringify!(x))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).z) as usize - ptr as usize },
        8usize,
        concat!("Offset of field: ", stringify!(Range), "::", stringify!(z))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sx) as usize - ptr as usize },
        12usize,
        concat!("Offset of field: ", stringify!(Range), "::", stringify!(sx))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sz) as usize - ptr as usize },
        16usize,
        concat!("Offset of field: ", stringify!(Range), "::", stringify!(sz))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        20usize,
        concat!("Offset of field: ", stringify!(Range), "::", stringify!(y))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sy) as usize - ptr as usize },
        24usize,
        concat!("Offset of field: ", stringify!(Range), "::", stringify!(sy))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialOrd, PartialEq)]
pub struct NetherNoise {
    pub temperature: DoublePerlinNoise,
    pub humidity: DoublePerlinNoise,
    pub oct: [PerlinNoise; 8usize],
}
#[test]
fn bindgen_test_layout_NetherNoise() {
    const UNINIT: ::std::mem::MaybeUninit<NetherNoise> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NetherNoise>(),
        2640usize,
        concat!("Size of: ", stringify!(NetherNoise))
    );
    assert_eq!(
        ::std::mem::align_of::<NetherNoise>(),
        8usize,
        concat!("Alignment of ", stringify!(NetherNoise))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).temperature) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NetherNoise),
            "::",
            stringify!(temperature)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).humidity) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(NetherNoise),
            "::",
            stringify!(humidity)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).oct) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(NetherNoise),
            "::",
            stringify!(oct)
        )
    );
}
impl Default for NetherNoise {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialOrd, PartialEq)]
pub struct EndNoise {
    pub perlin: PerlinNoise,
    pub mc: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_EndNoise() {
    const UNINIT: ::std::mem::MaybeUninit<EndNoise> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<EndNoise>(),
        328usize,
        concat!("Size of: ", stringify!(EndNoise))
    );
    assert_eq!(
        ::std::mem::align_of::<EndNoise>(),
        8usize,
        concat!("Alignment of ", stringify!(EndNoise))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).perlin) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EndNoise),
            "::",
            stringify!(perlin)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mc) as usize - ptr as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(EndNoise),
            "::",
            stringify!(mc)
        )
    );
}
impl Default for EndNoise {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialOrd, PartialEq)]
pub struct SurfaceNoise {
    pub xzScale: f64,
    pub yScale: f64,
    pub xzFactor: f64,
    pub yFactor: f64,
    pub octmin: OctaveNoise,
    pub octmax: OctaveNoise,
    pub octmain: OctaveNoise,
    pub octsurf: OctaveNoise,
    pub octdepth: OctaveNoise,
    pub oct: [PerlinNoise; 60usize],
}
#[test]
fn bindgen_test_layout_SurfaceNoise() {
    const UNINIT: ::std::mem::MaybeUninit<SurfaceNoise> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<SurfaceNoise>(),
        19312usize,
        concat!("Size of: ", stringify!(SurfaceNoise))
    );
    assert_eq!(
        ::std::mem::align_of::<SurfaceNoise>(),
        8usize,
        concat!("Alignment of ", stringify!(SurfaceNoise))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).xzScale) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SurfaceNoise),
            "::",
            stringify!(xzScale)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).yScale) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SurfaceNoise),
            "::",
            stringify!(yScale)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).xzFactor) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SurfaceNoise),
            "::",
            stringify!(xzFactor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).yFactor) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SurfaceNoise),
            "::",
            stringify!(yFactor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).octmin) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(SurfaceNoise),
            "::",
            stringify!(octmin)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).octmax) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(SurfaceNoise),
            "::",
            stringify!(octmax)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).octmain) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(SurfaceNoise),
            "::",
            stringify!(octmain)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).octsurf) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(SurfaceNoise),
            "::",
            stringify!(octsurf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).octdepth) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(SurfaceNoise),
            "::",
            stringify!(octdepth)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).oct) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(SurfaceNoise),
            "::",
            stringify!(oct)
        )
    );
}
impl Default for SurfaceNoise {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialOrd, PartialEq)]
pub struct SurfaceNoiseBeta {
    pub octmin: OctaveNoise,
    pub octmax: OctaveNoise,
    pub octmain: OctaveNoise,
    pub octcontA: OctaveNoise,
    pub octcontB: OctaveNoise,
    pub oct: [PerlinNoise; 66usize],
}
#[test]
fn bindgen_test_layout_SurfaceNoiseBeta() {
    const UNINIT: ::std::mem::MaybeUninit<SurfaceNoiseBeta> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<SurfaceNoiseBeta>(),
        21200usize,
        concat!("Size of: ", stringify!(SurfaceNoiseBeta))
    );
    assert_eq!(
        ::std::mem::align_of::<SurfaceNoiseBeta>(),
        8usize,
        concat!("Alignment of ", stringify!(SurfaceNoiseBeta))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).octmin) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SurfaceNoiseBeta),
            "::",
            stringify!(octmin)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).octmax) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SurfaceNoiseBeta),
            "::",
            stringify!(octmax)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).octmain) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(SurfaceNoiseBeta),
            "::",
            stringify!(octmain)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).octcontA) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(SurfaceNoiseBeta),
            "::",
            stringify!(octcontA)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).octcontB) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(SurfaceNoiseBeta),
            "::",
            stringify!(octcontB)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).oct) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(SurfaceNoiseBeta),
            "::",
            stringify!(oct)
        )
    );
}
impl Default for SurfaceNoiseBeta {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, PartialEq)]
pub struct SeaLevelColumnNoiseBeta {
    pub contASample: f64,
    pub contBSample: f64,
    pub minSample: [f64; 2usize],
    pub maxSample: [f64; 2usize],
    pub mainSample: [f64; 2usize],
}
#[test]
fn bindgen_test_layout_SeaLevelColumnNoiseBeta() {
    const UNINIT: ::std::mem::MaybeUninit<SeaLevelColumnNoiseBeta> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<SeaLevelColumnNoiseBeta>(),
        64usize,
        concat!("Size of: ", stringify!(SeaLevelColumnNoiseBeta))
    );
    assert_eq!(
        ::std::mem::align_of::<SeaLevelColumnNoiseBeta>(),
        8usize,
        concat!("Alignment of ", stringify!(SeaLevelColumnNoiseBeta))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).contASample) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SeaLevelColumnNoiseBeta),
            "::",
            stringify!(contASample)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).contBSample) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SeaLevelColumnNoiseBeta),
            "::",
            stringify!(contBSample)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).minSample) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SeaLevelColumnNoiseBeta),
            "::",
            stringify!(minSample)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxSample) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(SeaLevelColumnNoiseBeta),
            "::",
            stringify!(maxSample)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mainSample) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(SeaLevelColumnNoiseBeta),
            "::",
            stringify!(mainSample)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialOrd, PartialEq)]
pub struct Spline {
    pub len: ::std::os::raw::c_int,
    pub typ: ::std::os::raw::c_int,
    pub loc: [f32; 12usize],
    pub der: [f32; 12usize],
    pub val: [*mut Spline; 12usize],
}
#[test]
fn bindgen_test_layout_Spline() {
    const UNINIT: ::std::mem::MaybeUninit<Spline> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Spline>(),
        200usize,
        concat!("Size of: ", stringify!(Spline))
    );
    assert_eq!(
        ::std::mem::align_of::<Spline>(),
        8usize,
        concat!("Alignment of ", stringify!(Spline))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Spline),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).typ) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Spline),
            "::",
            stringify!(typ)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).loc) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Spline),
            "::",
            stringify!(loc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).der) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(Spline),
            "::",
            stringify!(der)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).val) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(Spline),
            "::",
            stringify!(val)
        )
    );
}
impl Default for Spline {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, PartialEq)]
pub struct FixSpline {
    pub len: ::std::os::raw::c_int,
    pub val: f32,
}
#[test]
fn bindgen_test_layout_FixSpline() {
    const UNINIT: ::std::mem::MaybeUninit<FixSpline> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<FixSpline>(),
        8usize,
        concat!("Size of: ", stringify!(FixSpline))
    );
    assert_eq!(
        ::std::mem::align_of::<FixSpline>(),
        4usize,
        concat!("Alignment of ", stringify!(FixSpline))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FixSpline),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).val) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(FixSpline),
            "::",
            stringify!(val)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialOrd, PartialEq)]
pub struct SplineStack {
    pub stack: [Spline; 42usize],
    pub fstack: [FixSpline; 151usize],
    pub len: ::std::os::raw::c_int,
    pub flen: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_SplineStack() {
    const UNINIT: ::std::mem::MaybeUninit<SplineStack> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<SplineStack>(),
        9616usize,
        concat!("Size of: ", stringify!(SplineStack))
    );
    assert_eq!(
        ::std::mem::align_of::<SplineStack>(),
        8usize,
        concat!("Alignment of ", stringify!(SplineStack))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stack) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SplineStack),
            "::",
            stringify!(stack)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fstack) as usize - ptr as usize },
        8400usize,
        concat!(
            "Offset of field: ",
            stringify!(SplineStack),
            "::",
            stringify!(fstack)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        9608usize,
        concat!(
            "Offset of field: ",
            stringify!(SplineStack),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flen) as usize - ptr as usize },
        9612usize,
        concat!(
            "Offset of field: ",
            stringify!(SplineStack),
            "::",
            stringify!(flen)
        )
    );
}
impl Default for SplineStack {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const NP_TEMPERATURE: _bindgen_ty_2 = 0;
pub const NP_HUMIDITY: _bindgen_ty_2 = 1;
pub const NP_CONTINENTALNESS: _bindgen_ty_2 = 2;
pub const NP_EROSION: _bindgen_ty_2 = 3;
pub const NP_SHIFT: _bindgen_ty_2 = 4;
pub const NP_DEPTH: _bindgen_ty_2 = 4;
pub const NP_WEIRDNESS: _bindgen_ty_2 = 5;
pub const NP_MAX: _bindgen_ty_2 = 6;
pub type _bindgen_ty_2 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialOrd, PartialEq)]
pub struct BiomeNoise {
    pub climate: [DoublePerlinNoise; 6usize],
    pub oct: [PerlinNoise; 46usize],
    pub sp: *mut Spline,
    pub ss: SplineStack,
    pub nptype: ::std::os::raw::c_int,
    pub mc: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_BiomeNoise() {
    const UNINIT: ::std::mem::MaybeUninit<BiomeNoise> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<BiomeNoise>(),
        24592usize,
        concat!("Size of: ", stringify!(BiomeNoise))
    );
    assert_eq!(
        ::std::mem::align_of::<BiomeNoise>(),
        8usize,
        concat!("Alignment of ", stringify!(BiomeNoise))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).climate) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BiomeNoise),
            "::",
            stringify!(climate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).oct) as usize - ptr as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(BiomeNoise),
            "::",
            stringify!(oct)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sp) as usize - ptr as usize },
        14960usize,
        concat!(
            "Offset of field: ",
            stringify!(BiomeNoise),
            "::",
            stringify!(sp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ss) as usize - ptr as usize },
        14968usize,
        concat!(
            "Offset of field: ",
            stringify!(BiomeNoise),
            "::",
            stringify!(ss)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nptype) as usize - ptr as usize },
        24584usize,
        concat!(
            "Offset of field: ",
            stringify!(BiomeNoise),
            "::",
            stringify!(nptype)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mc) as usize - ptr as usize },
        24588usize,
        concat!(
            "Offset of field: ",
            stringify!(BiomeNoise),
            "::",
            stringify!(mc)
        )
    );
}
impl Default for BiomeNoise {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialOrd, PartialEq)]
pub struct BiomeNoiseBeta {
    pub climate: [OctaveNoise; 3usize],
    pub oct: [PerlinNoise; 10usize],
    pub nptype: ::std::os::raw::c_int,
    pub mc: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_BiomeNoiseBeta() {
    const UNINIT: ::std::mem::MaybeUninit<BiomeNoiseBeta> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<BiomeNoiseBeta>(),
        3256usize,
        concat!("Size of: ", stringify!(BiomeNoiseBeta))
    );
    assert_eq!(
        ::std::mem::align_of::<BiomeNoiseBeta>(),
        8usize,
        concat!("Alignment of ", stringify!(BiomeNoiseBeta))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).climate) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BiomeNoiseBeta),
            "::",
            stringify!(climate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).oct) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(BiomeNoiseBeta),
            "::",
            stringify!(oct)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nptype) as usize - ptr as usize },
        3248usize,
        concat!(
            "Offset of field: ",
            stringify!(BiomeNoiseBeta),
            "::",
            stringify!(nptype)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mc) as usize - ptr as usize },
        3252usize,
        concat!(
            "Offset of field: ",
            stringify!(BiomeNoiseBeta),
            "::",
            stringify!(mc)
        )
    );
}
impl Default for BiomeNoiseBeta {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct BiomeTree {
    pub steps: *const u32,
    pub param: *const i32,
    pub nodes: *const u64,
    pub order: u32,
    pub len: u32,
}
#[test]
fn bindgen_test_layout_BiomeTree() {
    const UNINIT: ::std::mem::MaybeUninit<BiomeTree> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<BiomeTree>(),
        32usize,
        concat!("Size of: ", stringify!(BiomeTree))
    );
    assert_eq!(
        ::std::mem::align_of::<BiomeTree>(),
        8usize,
        concat!("Alignment of ", stringify!(BiomeTree))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).steps) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BiomeTree),
            "::",
            stringify!(steps)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).param) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(BiomeTree),
            "::",
            stringify!(param)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nodes) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(BiomeTree),
            "::",
            stringify!(nodes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).order) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(BiomeTree),
            "::",
            stringify!(order)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(BiomeTree),
            "::",
            stringify!(len)
        )
    );
}
impl Default for BiomeTree {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub static mut g_btree: [BiomeTree; 4usize];
}
extern "C" {
    pub fn initSurfaceNoise(sn: *mut SurfaceNoise, dim: ::std::os::raw::c_int, seed: u64);
}
extern "C" {
    pub fn initSurfaceNoiseBeta(snb: *mut SurfaceNoiseBeta, seed: u64);
}
extern "C" {
    pub fn sampleSurfaceNoise(
        sn: *const SurfaceNoise,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
        z: ::std::os::raw::c_int,
    ) -> f64;
}
extern "C" {
    #[doc = " Nether biomes are 3D, and generated at scale 1:4. Use voronoiAccess3D() to\n convert coordinates at 1:1 scale to their 1:4 access. Biome checks for\n structures are generally done at y=0.\n\n The function getNetherBiome() determines the nether biome at a given\n coordinate at scale 1:4. The parameter 'ndel' is an output noise delta for\n optimization purposes and can be ignored (nullable).\n\n Use mapNether2D() to get a 2D area of nether biomes at y=0, scale 1:4.\n\n The mapNether3D() function attempts to optimize the generation of a volume\n at scale 1:4. The output is indexed as:\n out[i_y*(r.sx*r.sz) + i_z*r.sx + i_x].\n If the optimization parameter 'confidence' has a value less than 1.0, the\n generation will generally be faster, but can yield incorrect results in some\n circumstances.\n\n The output buffer for the map-functions need only be of sufficient size to\n hold the generated area (i.e. w*h or r.sx*r.sy*r.sz)."]
    pub fn setNetherSeed(nn: *mut NetherNoise, seed: u64);
}
extern "C" {
    pub fn getNetherBiome(
        nn: *const NetherNoise,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
        z: ::std::os::raw::c_int,
        ndel: *mut f32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mapNether2D(
        nn: *const NetherNoise,
        out: *mut ::std::os::raw::c_int,
        x: ::std::os::raw::c_int,
        z: ::std::os::raw::c_int,
        w: ::std::os::raw::c_int,
        h: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mapNether3D(
        nn: *const NetherNoise,
        out: *mut ::std::os::raw::c_int,
        r: Range,
        confidence: f32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " The scaled Nether generation supports scales 1, 4, 16, 64, and 256.\n It is similar to mapNether3D(), but applies voronoi zoom if necessary, and\n fills the output buffer with nether_wastes for versions older than 1.16."]
    pub fn genNetherScaled(
        nn: *const NetherNoise,
        out: *mut ::std::os::raw::c_int,
        r: Range,
        mc: ::std::os::raw::c_int,
        sha: u64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " End biome generation is based on simplex noise and varies only at a 1:16\n chunk scale which can be generated with mapEndBiome(). The function mapEnd()\n is a variation which also scales this up on a regular grid to 1:4. The final\n access at a 1:1 scale uses voronoi."]
    pub fn setEndSeed(en: *mut EndNoise, mc: ::std::os::raw::c_int, seed: u64);
}
extern "C" {
    pub fn mapEndBiome(
        en: *const EndNoise,
        out: *mut ::std::os::raw::c_int,
        x: ::std::os::raw::c_int,
        z: ::std::os::raw::c_int,
        w: ::std::os::raw::c_int,
        h: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mapEnd(
        en: *const EndNoise,
        out: *mut ::std::os::raw::c_int,
        x: ::std::os::raw::c_int,
        z: ::std::os::raw::c_int,
        w: ::std::os::raw::c_int,
        h: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getSurfaceHeightEnd(
        mc: ::std::os::raw::c_int,
        seed: u64,
        x: ::std::os::raw::c_int,
        z: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " The scaled End generation supports scales 1, 4, 16, and 64.\n The End biomes are usually 2D, but in 1.15+ there is 3D voronoi noise, which\n is controlled by the 'sha' hash of the seed. For scales higher than 1:1, and\n versions up to 1.14, 'sha' is ignored."]
    pub fn genEndScaled(
        en: *const EndNoise,
        out: *mut ::std::os::raw::c_int,
        r: Range,
        mc: ::std::os::raw::c_int,
        sha: u64,
    ) -> ::std::os::raw::c_int;
}
pub const SAMPLE_NO_SHIFT: _bindgen_ty_3 = 1;
pub const SAMPLE_NO_DEPTH: _bindgen_ty_3 = 2;
pub const SAMPLE_NO_BIOME: _bindgen_ty_3 = 4;
#[doc = " In 1.18 the Overworld uses a new noise map system for the biome generation.\n The random number generation also has updated to a Xiroshiro128 algorithm.\n The scale is 1:4, and is sampled at each point individually as there is\n currently not much benefit from generating a volume as a whole.\n\n The 1.18 End generation remains similar to 1.17 and does NOT use the\n biome noise."]
pub type _bindgen_ty_3 = ::std::os::raw::c_uint;
extern "C" {
    pub fn initBiomeNoise(bn: *mut BiomeNoise, mc: ::std::os::raw::c_int);
}
extern "C" {
    pub fn setBiomeSeed(bn: *mut BiomeNoise, seed: u64, large: ::std::os::raw::c_int);
}
extern "C" {
    pub fn setBetaBiomeSeed(bnb: *mut BiomeNoiseBeta, seed: u64);
}
extern "C" {
    pub fn sampleBiomeNoise(
        bn: *const BiomeNoise,
        np: *mut i64,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
        z: ::std::os::raw::c_int,
        dat: *mut u64,
        sample_flags: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sampleBiomeNoiseBeta(
        bnb: *const BiomeNoiseBeta,
        np: *mut i64,
        nv: *mut f64,
        x: ::std::os::raw::c_int,
        z: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn approxSurfaceBeta(
        bnb: *const BiomeNoiseBeta,
        snb: *const SurfaceNoiseBeta,
        x: ::std::os::raw::c_int,
        z: ::std::os::raw::c_int,
    ) -> f64;
}
extern "C" {
    #[doc = " (Alpha 1.2 - Beta 1.7)\n Temperature and humidity values to biome."]
    pub fn getOldBetaBiome(t: f32, h: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Uses the global biome tree definition (g_btree) to map a noise point\n (i.e. climate) to the corresponding overworld biome."]
    pub fn climateToBiome(
        mc: ::std::os::raw::c_int,
        np: *const u64,
        dat: *mut u64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Initialize BiomeNoise for only a single climate parameter.\n If nptype == NP_DEPTH, the value is sampled at y=0. Note that this value\n changes linearly with the height (i.e. -= y/128).\n A maximum of nmax octaves is set, initializing only the most contributing\n octaves up to that point. Use -1 for a full initialization."]
    pub fn setClimateParaSeed(
        bn: *mut BiomeNoise,
        seed: u64,
        large: ::std::os::raw::c_int,
        nptype: ::std::os::raw::c_int,
        nmax: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn sampleClimatePara(bn: *const BiomeNoise, np: *mut i64, x: f64, z: f64) -> f64;
}
extern "C" {
    #[doc = " Currently, in 1.18, we have to generate biomes one chunk at a time to get an\n accurate mapping of the biomes in the level storage, as there is no longer a\n unique mapping from noise points to biomes (MC-241546). Note that the results\n from this are not suitable for chunk population/structure generation.\n The output is in the form out[x][y][z] for the 64 biome points in the chunk\n section. The coordinates {cx,cy,cz} are all at scale 1:16 and the 'dat'\n argument should be the previous noise sampling and can be left NULL."]
    pub fn genBiomeNoiseChunkSection(
        bn: *const BiomeNoise,
        out: *mut [[::std::os::raw::c_int; 4usize]; 4usize],
        cx: ::std::os::raw::c_int,
        cy: ::std::os::raw::c_int,
        cz: ::std::os::raw::c_int,
        dat: *mut u64,
    );
}
extern "C" {
    #[doc = " The scaled biome noise generation applies for the Overworld version 1.18+.\n The 'sha' hash of the seed is only required for voronoi at scale 1:1.\n A scale of zero is interpreted as the default 1:4 scale."]
    pub fn genBiomeNoiseScaled(
        bn: *const BiomeNoise,
        out: *mut ::std::os::raw::c_int,
        r: Range,
        sha: u64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Generates the biomes for Beta 1.7, the surface noise is optional and enables\n ocean mapping in areas that fall below the sea level."]
    pub fn genBiomeNoiseBetaScaled(
        bnb: *const BiomeNoiseBeta,
        snb: *const SurfaceNoiseBeta,
        out: *mut ::std::os::raw::c_int,
        r: Range,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getVoronoiSrcRange(r: Range) -> Range;
}
pub const LARGE_BIOMES: _bindgen_ty_4 = 1;
pub const NO_BETA_OCEAN: _bindgen_ty_4 = 2;
pub const FORCE_OCEAN_VARIANTS: _bindgen_ty_4 = 4;
pub type _bindgen_ty_4 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Generator {
    pub mc: ::std::os::raw::c_int,
    pub dim: ::std::os::raw::c_int,
    pub flags: u32,
    pub seed: u64,
    pub sha: u64,
    pub __bindgen_anon_1: Generator__bindgen_ty_1,
    pub nn: NetherNoise,
    pub en: EndNoise,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union Generator__bindgen_ty_1 {
    pub __bindgen_anon_1: Generator__bindgen_ty_1__bindgen_ty_1,
    pub __bindgen_anon_2: Generator__bindgen_ty_1__bindgen_ty_2,
    pub __bindgen_anon_3: Generator__bindgen_ty_1__bindgen_ty_3,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialOrd, PartialEq)]
pub struct Generator__bindgen_ty_1__bindgen_ty_1 {
    pub ls: LayerStack,
    pub xlayer: [Layer; 5usize],
    pub entry: *mut Layer,
}
#[test]
fn bindgen_test_layout_Generator__bindgen_ty_1__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<Generator__bindgen_ty_1__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Generator__bindgen_ty_1__bindgen_ty_1>(),
        5120usize,
        concat!(
            "Size of: ",
            stringify!(Generator__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<Generator__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(Generator__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ls) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Generator__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(ls)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).xlayer) as usize - ptr as usize },
        4752usize,
        concat!(
            "Offset of field: ",
            stringify!(Generator__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(xlayer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).entry) as usize - ptr as usize },
        5112usize,
        concat!(
            "Offset of field: ",
            stringify!(Generator__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(entry)
        )
    );
}
impl Default for Generator__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialOrd, PartialEq)]
pub struct Generator__bindgen_ty_1__bindgen_ty_2 {
    pub bn: BiomeNoise,
}
#[test]
fn bindgen_test_layout_Generator__bindgen_ty_1__bindgen_ty_2() {
    const UNINIT: ::std::mem::MaybeUninit<Generator__bindgen_ty_1__bindgen_ty_2> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Generator__bindgen_ty_1__bindgen_ty_2>(),
        24592usize,
        concat!(
            "Size of: ",
            stringify!(Generator__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<Generator__bindgen_ty_1__bindgen_ty_2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(Generator__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bn) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Generator__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(bn)
        )
    );
}
impl Default for Generator__bindgen_ty_1__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialOrd, PartialEq)]
pub struct Generator__bindgen_ty_1__bindgen_ty_3 {
    pub bnb: BiomeNoiseBeta,
}
#[test]
fn bindgen_test_layout_Generator__bindgen_ty_1__bindgen_ty_3() {
    const UNINIT: ::std::mem::MaybeUninit<Generator__bindgen_ty_1__bindgen_ty_3> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Generator__bindgen_ty_1__bindgen_ty_3>(),
        3256usize,
        concat!(
            "Size of: ",
            stringify!(Generator__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<Generator__bindgen_ty_1__bindgen_ty_3>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(Generator__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bnb) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Generator__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(bnb)
        )
    );
}
impl Default for Generator__bindgen_ty_1__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout_Generator__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<Generator__bindgen_ty_1>(),
        24592usize,
        concat!("Size of: ", stringify!(Generator__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<Generator__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(Generator__bindgen_ty_1))
    );
}
impl Default for Generator__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout_Generator() {
    const UNINIT: ::std::mem::MaybeUninit<Generator> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Generator>(),
        27592usize,
        concat!("Size of: ", stringify!(Generator))
    );
    assert_eq!(
        ::std::mem::align_of::<Generator>(),
        8usize,
        concat!("Alignment of ", stringify!(Generator))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mc) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Generator),
            "::",
            stringify!(mc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dim) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Generator),
            "::",
            stringify!(dim)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Generator),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).seed) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Generator),
            "::",
            stringify!(seed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sha) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(Generator),
            "::",
            stringify!(sha)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nn) as usize - ptr as usize },
        24624usize,
        concat!(
            "Offset of field: ",
            stringify!(Generator),
            "::",
            stringify!(nn)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).en) as usize - ptr as usize },
        27264usize,
        concat!(
            "Offset of field: ",
            stringify!(Generator),
            "::",
            stringify!(en)
        )
    );
}
impl Default for Generator {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " Sets up a biome generator for a given MC version. The 'flags' can be used to\n control LARGE_BIOMES or to FORCE_OCEAN_VARIANTS to enable ocean variants at\n scales higher than normal."]
    pub fn setupGenerator(g: *mut Generator, mc: ::std::os::raw::c_int, flags: u32);
}
extern "C" {
    #[doc = " Initializes the generator for a given dimension and seed.\n dim=0:   Overworld\n dim=-1:  Nether\n dim=+1:  End"]
    pub fn applySeed(g: *mut Generator, dim: ::std::os::raw::c_int, seed: u64);
}
extern "C" {
    #[doc = " Calculates the buffer size (number of ints) required to generate a cuboidal\n volume of size (sx, sy, sz). If 'sy' is zero the buffer is calculated for a\n 2D plane (which is equivalent to sy=1 here).\n The function allocCache() can be used to allocate the corresponding int\n buffer using malloc()."]
    pub fn getMinCacheSize(
        g: *const Generator,
        scale: ::std::os::raw::c_int,
        sx: ::std::os::raw::c_int,
        sy: ::std::os::raw::c_int,
        sz: ::std::os::raw::c_int,
    ) -> usize;
}
extern "C" {
    pub fn allocCache(g: *const Generator, r: Range) -> *mut ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Generates the biomes for a cuboidal scaled range given by 'r'.\n (See description of Range for more detail.)\n\n The output is generated inside the cache. Upon success the biome ids can be\n accessed by indexing as:\n  cache[ y*r.sx*r.sz + z*r.sx + x ]\n where (x,y,z) is an relative position inside the range cuboid.\n\n The required length of the cache can be determined with getMinCacheSize().\n\n The return value is zero upon success."]
    pub fn genBiomes(
        g: *const Generator,
        cache: *mut ::std::os::raw::c_int,
        r: Range,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Gets the biome for a specified scaled position. Note that the scale should\n be either 1 or 4, for block or biome coordinates respectively.\n Returns none (-1) upon failure."]
    pub fn getBiomeAt(
        g: *const Generator,
        scale: ::std::os::raw::c_int,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
        z: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns the default layer that corresponds to the given scale.\n Supported scales are {0, 1, 4, 16, 64, 256}. A scale of zero indicates the\n custom entry layer 'g->entry'.\n (Overworld, MC <= 1.17)"]
    pub fn getLayerForScale(g: *const Generator, scale: ::std::os::raw::c_int) -> *const Layer;
}
extern "C" {
    #[doc = "=============================================================================\n Layered Biome Generation (old interface up to 1.17)\n============================================================================="]
    pub fn setupLayerStack(
        g: *mut LayerStack,
        mc: ::std::os::raw::c_int,
        largeBiomes: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn getMinLayerCacheSize(
        layer: *const Layer,
        sizeX: ::std::os::raw::c_int,
        sizeZ: ::std::os::raw::c_int,
    ) -> usize;
}
extern "C" {
    pub fn setupLayer(
        l: *mut Layer,
        map: mapfunc_t,
        mc: ::std::os::raw::c_int,
        zoom: i8,
        edge: i8,
        saltbase: u64,
        p: *mut Layer,
        p2: *mut Layer,
    ) -> *mut Layer;
}
extern "C" {
    pub fn genArea(
        layer: *const Layer,
        out: *mut ::std::os::raw::c_int,
        areaX: ::std::os::raw::c_int,
        areaZ: ::std::os::raw::c_int,
        areaWidth: ::std::os::raw::c_int,
        areaHeight: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Map an approximation of the Overworld surface height.\n The horizontal scaling is 1:4. If non-null, the ids are filled with the\n biomes of the area. The height (written to y) is in blocks."]
    pub fn mapApproxHeight(
        y: *mut f32,
        ids: *mut ::std::os::raw::c_int,
        g: *const Generator,
        sn: *const SurfaceNoise,
        x: ::std::os::raw::c_int,
        z: ::std::os::raw::c_int,
        w: ::std::os::raw::c_int,
        h: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
pub const StructureType_Feature: StructureType = 0;
pub const StructureType_Desert_Pyramid: StructureType = 1;
pub const StructureType_Jungle_Temple: StructureType = 2;
pub const StructureType_Jungle_Pyramid: StructureType = 2;
pub const StructureType_Swamp_Hut: StructureType = 3;
pub const StructureType_Igloo: StructureType = 4;
pub const StructureType_Village: StructureType = 5;
pub const StructureType_Ocean_Ruin: StructureType = 6;
pub const StructureType_Shipwreck: StructureType = 7;
pub const StructureType_Monument: StructureType = 8;
pub const StructureType_Mansion: StructureType = 9;
pub const StructureType_Outpost: StructureType = 10;
pub const StructureType_Ruined_Portal: StructureType = 11;
pub const StructureType_Ruined_Portal_N: StructureType = 12;
pub const StructureType_Ancient_City: StructureType = 13;
pub const StructureType_Treasure: StructureType = 14;
pub const StructureType_Mineshaft: StructureType = 15;
pub const StructureType_Desert_Well: StructureType = 16;
pub const StructureType_Geode: StructureType = 17;
pub const StructureType_Fortress: StructureType = 18;
pub const StructureType_Bastion: StructureType = 19;
pub const StructureType_End_City: StructureType = 20;
pub const StructureType_End_Gateway: StructureType = 21;
pub const StructureType_Trail_Ruin: StructureType = 22;
pub const StructureType_FEATURE_NUM: StructureType = 23;
pub type StructureType = ::std::os::raw::c_uint;
pub const STRUCT_TRIANGULAR: _bindgen_ty_5 = 1;
pub const STRUCT_CHUNK: _bindgen_ty_5 = 2;
pub const STRUCT_NETHER: _bindgen_ty_5 = 16;
pub const STRUCT_END: _bindgen_ty_5 = 32;
pub type _bindgen_ty_5 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, PartialEq)]
pub struct StructureConfig {
    pub salt: i32,
    pub regionSize: i8,
    pub chunkRange: i8,
    pub structType: u8,
    pub properties: u8,
    pub rarity: f32,
}
#[test]
fn bindgen_test_layout_StructureConfig() {
    const UNINIT: ::std::mem::MaybeUninit<StructureConfig> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<StructureConfig>(),
        12usize,
        concat!("Size of: ", stringify!(StructureConfig))
    );
    assert_eq!(
        ::std::mem::align_of::<StructureConfig>(),
        4usize,
        concat!("Alignment of ", stringify!(StructureConfig))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).salt) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(StructureConfig),
            "::",
            stringify!(salt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).regionSize) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(StructureConfig),
            "::",
            stringify!(regionSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).chunkRange) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(StructureConfig),
            "::",
            stringify!(chunkRange)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).structType) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(StructureConfig),
            "::",
            stringify!(structType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).properties) as usize - ptr as usize },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(StructureConfig),
            "::",
            stringify!(properties)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rarity) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(StructureConfig),
            "::",
            stringify!(rarity)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct Pos {
    pub x: ::std::os::raw::c_int,
    pub z: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_Pos() {
    const UNINIT: ::std::mem::MaybeUninit<Pos> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Pos>(),
        8usize,
        concat!("Size of: ", stringify!(Pos))
    );
    assert_eq!(
        ::std::mem::align_of::<Pos>(),
        4usize,
        concat!("Alignment of ", stringify!(Pos))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(Pos), "::", stringify!(x))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).z) as usize - ptr as usize },
        4usize,
        concat!("Offset of field: ", stringify!(Pos), "::", stringify!(z))
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct Pos3 {
    pub x: ::std::os::raw::c_int,
    pub y: ::std::os::raw::c_int,
    pub z: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_Pos3() {
    const UNINIT: ::std::mem::MaybeUninit<Pos3> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Pos3>(),
        12usize,
        concat!("Size of: ", stringify!(Pos3))
    );
    assert_eq!(
        ::std::mem::align_of::<Pos3>(),
        4usize,
        concat!("Alignment of ", stringify!(Pos3))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(Pos3), "::", stringify!(x))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        4usize,
        concat!("Offset of field: ", stringify!(Pos3), "::", stringify!(y))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).z) as usize - ptr as usize },
        8usize,
        concat!("Offset of field: ", stringify!(Pos3), "::", stringify!(z))
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, PartialEq)]
pub struct StrongholdIter {
    pub pos: Pos,
    pub nextapprox: Pos,
    pub index: ::std::os::raw::c_int,
    pub ringnum: ::std::os::raw::c_int,
    pub ringmax: ::std::os::raw::c_int,
    pub ringidx: ::std::os::raw::c_int,
    pub angle: f64,
    pub dist: f64,
    pub rnds: u64,
    pub mc: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_StrongholdIter() {
    const UNINIT: ::std::mem::MaybeUninit<StrongholdIter> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<StrongholdIter>(),
        64usize,
        concat!("Size of: ", stringify!(StrongholdIter))
    );
    assert_eq!(
        ::std::mem::align_of::<StrongholdIter>(),
        8usize,
        concat!("Alignment of ", stringify!(StrongholdIter))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pos) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(StrongholdIter),
            "::",
            stringify!(pos)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nextapprox) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(StrongholdIter),
            "::",
            stringify!(nextapprox)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).index) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(StrongholdIter),
            "::",
            stringify!(index)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ringnum) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(StrongholdIter),
            "::",
            stringify!(ringnum)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ringmax) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(StrongholdIter),
            "::",
            stringify!(ringmax)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ringidx) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(StrongholdIter),
            "::",
            stringify!(ringidx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).angle) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(StrongholdIter),
            "::",
            stringify!(angle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dist) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(StrongholdIter),
            "::",
            stringify!(dist)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rnds) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(StrongholdIter),
            "::",
            stringify!(rnds)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mc) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(StrongholdIter),
            "::",
            stringify!(mc)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct StructureVariant {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub size: u8,
    pub start: u8,
    pub biome: ::std::os::raw::c_short,
    pub rotation: u8,
    pub mirror: u8,
    pub x: i16,
    pub y: i16,
    pub z: i16,
    pub sx: i16,
    pub sy: i16,
    pub sz: i16,
}
#[test]
fn bindgen_test_layout_StructureVariant() {
    const UNINIT: ::std::mem::MaybeUninit<StructureVariant> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<StructureVariant>(),
        20usize,
        concat!("Size of: ", stringify!(StructureVariant))
    );
    assert_eq!(
        ::std::mem::align_of::<StructureVariant>(),
        2usize,
        concat!("Alignment of ", stringify!(StructureVariant))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(StructureVariant),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).start) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(StructureVariant),
            "::",
            stringify!(start)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).biome) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(StructureVariant),
            "::",
            stringify!(biome)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rotation) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(StructureVariant),
            "::",
            stringify!(rotation)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mirror) as usize - ptr as usize },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(StructureVariant),
            "::",
            stringify!(mirror)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(StructureVariant),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(StructureVariant),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).z) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(StructureVariant),
            "::",
            stringify!(z)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sx) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(StructureVariant),
            "::",
            stringify!(sx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sy) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(StructureVariant),
            "::",
            stringify!(sy)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sz) as usize - ptr as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(StructureVariant),
            "::",
            stringify!(sz)
        )
    );
}
impl StructureVariant {
    #[inline]
    pub fn abandoned(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_abandoned(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn giant(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_giant(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn underground(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_underground(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn airpocket(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_airpocket(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn basement(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_basement(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cracked(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_cracked(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        abandoned: u8,
        giant: u8,
        underground: u8,
        airpocket: u8,
        basement: u8,
        cracked: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let abandoned: u8 = unsafe { ::std::mem::transmute(abandoned) };
            abandoned as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let giant: u8 = unsafe { ::std::mem::transmute(giant) };
            giant as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let underground: u8 = unsafe { ::std::mem::transmute(underground) };
            underground as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let airpocket: u8 = unsafe { ::std::mem::transmute(airpocket) };
            airpocket as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let basement: u8 = unsafe { ::std::mem::transmute(basement) };
            basement as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let cracked: u8 = unsafe { ::std::mem::transmute(cracked) };
            cracked as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct Piece {
    pub name: *const ::std::os::raw::c_char,
    pub pos: Pos3,
    pub bb0: Pos3,
    pub bb1: Pos3,
    pub rot: u8,
    pub depth: i8,
    pub type_: i8,
    pub next: *mut Piece,
}
#[test]
fn bindgen_test_layout_Piece() {
    const UNINIT: ::std::mem::MaybeUninit<Piece> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Piece>(),
        56usize,
        concat!("Size of: ", stringify!(Piece))
    );
    assert_eq!(
        ::std::mem::align_of::<Piece>(),
        8usize,
        concat!("Alignment of ", stringify!(Piece))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Piece),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pos) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Piece),
            "::",
            stringify!(pos)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bb0) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(Piece),
            "::",
            stringify!(bb0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bb1) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(Piece),
            "::",
            stringify!(bb1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rot) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(Piece),
            "::",
            stringify!(rot)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).depth) as usize - ptr as usize },
        45usize,
        concat!(
            "Offset of field: ",
            stringify!(Piece),
            "::",
            stringify!(depth)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        46usize,
        concat!(
            "Offset of field: ",
            stringify!(Piece),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(Piece),
            "::",
            stringify!(next)
        )
    );
}
impl Default for Piece {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const BF_APPROX: _bindgen_ty_6 = 1;
pub const BF_FORCED_OCEAN: _bindgen_ty_6 = 4;
pub type _bindgen_ty_6 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct BiomeFilter {
    pub tempsToFind: u64,
    pub otempToFind: u64,
    pub majorToFind: u64,
    pub edgesToFind: u64,
    pub raresToFind: u64,
    pub raresToFindM: u64,
    pub shoreToFind: u64,
    pub shoreToFindM: u64,
    pub riverToFind: u64,
    pub riverToFindM: u64,
    pub oceanToFind: u64,
    pub specialCnt: ::std::os::raw::c_int,
    pub flags: u32,
    pub tempsToExcl: u64,
    pub majorToExcl: u64,
    pub edgesToExcl: u64,
    pub raresToExcl: u64,
    pub raresToExclM: u64,
    pub shoreToExcl: u64,
    pub shoreToExclM: u64,
    pub riverToExcl: u64,
    pub riverToExclM: u64,
    pub biomeToExcl: u64,
    pub biomeToExclM: u64,
    pub biomeToFind: u64,
    pub biomeToFindM: u64,
    pub biomeToPick: u64,
    pub biomeToPickM: u64,
}
#[test]
fn bindgen_test_layout_BiomeFilter() {
    const UNINIT: ::std::mem::MaybeUninit<BiomeFilter> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<BiomeFilter>(),
        216usize,
        concat!("Size of: ", stringify!(BiomeFilter))
    );
    assert_eq!(
        ::std::mem::align_of::<BiomeFilter>(),
        8usize,
        concat!("Alignment of ", stringify!(BiomeFilter))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tempsToFind) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BiomeFilter),
            "::",
            stringify!(tempsToFind)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).otempToFind) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(BiomeFilter),
            "::",
            stringify!(otempToFind)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).majorToFind) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(BiomeFilter),
            "::",
            stringify!(majorToFind)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).edgesToFind) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(BiomeFilter),
            "::",
            stringify!(edgesToFind)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).raresToFind) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(BiomeFilter),
            "::",
            stringify!(raresToFind)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).raresToFindM) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(BiomeFilter),
            "::",
            stringify!(raresToFindM)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).shoreToFind) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(BiomeFilter),
            "::",
            stringify!(shoreToFind)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).shoreToFindM) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(BiomeFilter),
            "::",
            stringify!(shoreToFindM)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).riverToFind) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(BiomeFilter),
            "::",
            stringify!(riverToFind)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).riverToFindM) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(BiomeFilter),
            "::",
            stringify!(riverToFindM)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).oceanToFind) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(BiomeFilter),
            "::",
            stringify!(oceanToFind)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).specialCnt) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(BiomeFilter),
            "::",
            stringify!(specialCnt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(BiomeFilter),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tempsToExcl) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(BiomeFilter),
            "::",
            stringify!(tempsToExcl)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).majorToExcl) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(BiomeFilter),
            "::",
            stringify!(majorToExcl)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).edgesToExcl) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(BiomeFilter),
            "::",
            stringify!(edgesToExcl)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).raresToExcl) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(BiomeFilter),
            "::",
            stringify!(raresToExcl)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).raresToExclM) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(BiomeFilter),
            "::",
            stringify!(raresToExclM)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).shoreToExcl) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(BiomeFilter),
            "::",
            stringify!(shoreToExcl)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).shoreToExclM) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(BiomeFilter),
            "::",
            stringify!(shoreToExclM)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).riverToExcl) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(BiomeFilter),
            "::",
            stringify!(riverToExcl)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).riverToExclM) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(BiomeFilter),
            "::",
            stringify!(riverToExclM)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).biomeToExcl) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(BiomeFilter),
            "::",
            stringify!(biomeToExcl)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).biomeToExclM) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(BiomeFilter),
            "::",
            stringify!(biomeToExclM)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).biomeToFind) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(BiomeFilter),
            "::",
            stringify!(biomeToFind)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).biomeToFindM) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(BiomeFilter),
            "::",
            stringify!(biomeToFindM)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).biomeToPick) as usize - ptr as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(BiomeFilter),
            "::",
            stringify!(biomeToPick)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).biomeToPickM) as usize - ptr as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(BiomeFilter),
            "::",
            stringify!(biomeToPickM)
        )
    );
}
extern "C" {
    pub fn getStructureConfig(
        structureType: ::std::os::raw::c_int,
        mc: ::std::os::raw::c_int,
        sconf: *mut StructureConfig,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getStructurePos(
        structureType: ::std::os::raw::c_int,
        mc: ::std::os::raw::c_int,
        seed: u64,
        regX: ::std::os::raw::c_int,
        regZ: ::std::os::raw::c_int,
        pos: *mut Pos,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getMineshafts(
        mc: ::std::os::raw::c_int,
        seed: u64,
        chunkX: ::std::os::raw::c_int,
        chunkZ: ::std::os::raw::c_int,
        chunkW: ::std::os::raw::c_int,
        chunkH: ::std::os::raw::c_int,
        out: *mut Pos,
        nout: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn initFirstStronghold(sh: *mut StrongholdIter, mc: ::std::os::raw::c_int, s48: u64)
        -> Pos;
}
extern "C" {
    pub fn nextStronghold(sh: *mut StrongholdIter, g: *const Generator) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn estimateSpawn(g: *const Generator, rng: *mut u64) -> Pos;
}
extern "C" {
    pub fn getSpawn(g: *const Generator) -> Pos;
}
extern "C" {
    pub fn locateBiome(
        g: *const Generator,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
        z: ::std::os::raw::c_int,
        radius: ::std::os::raw::c_int,
        validB: u64,
        validM: u64,
        rng: *mut u64,
        passes: *mut ::std::os::raw::c_int,
    ) -> Pos;
}
extern "C" {
    pub fn isViableStructurePos(
        structType: ::std::os::raw::c_int,
        g: *mut Generator,
        blockX: ::std::os::raw::c_int,
        blockZ: ::std::os::raw::c_int,
        flags: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isViableFeatureBiome(
        mc: ::std::os::raw::c_int,
        structureType: ::std::os::raw::c_int,
        biomeID: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isViableStructureTerrain(
        structType: ::std::os::raw::c_int,
        g: *mut Generator,
        blockX: ::std::os::raw::c_int,
        blockZ: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isViableEndCityTerrain(
        g: *const Generator,
        sn: *const SurfaceNoise,
        blockX: ::std::os::raw::c_int,
        blockZ: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getVariant(
        sv: *mut StructureVariant,
        structType: ::std::os::raw::c_int,
        mc: ::std::os::raw::c_int,
        seed: u64,
        blockX: ::std::os::raw::c_int,
        blockZ: ::std::os::raw::c_int,
        biomeID: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getEndCityPieces(
        pieces: *mut Piece,
        seed: u64,
        chunkX: ::std::os::raw::c_int,
        chunkZ: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
pub const BASE_FLOOR: _bindgen_ty_7 = 0;
pub const BASE_ROOF: _bindgen_ty_7 = 1;
pub const BRIDGE_END: _bindgen_ty_7 = 2;
pub const BRIDGE_GENTLE_STAIRS: _bindgen_ty_7 = 3;
pub const BRIDGE_PIECE: _bindgen_ty_7 = 4;
pub const BRIDGE_STEEP_STAIRS: _bindgen_ty_7 = 5;
pub const FAT_TOWER_BASE: _bindgen_ty_7 = 6;
pub const FAT_TOWER_MIDDLE: _bindgen_ty_7 = 7;
pub const FAT_TOWER_TOP: _bindgen_ty_7 = 8;
pub const SECOND_FLOOR_1: _bindgen_ty_7 = 9;
pub const SECOND_FLOOR_2: _bindgen_ty_7 = 10;
pub const SECOND_ROOF: _bindgen_ty_7 = 11;
pub const END_SHIP: _bindgen_ty_7 = 12;
pub const THIRD_FLOOR_1: _bindgen_ty_7 = 13;
pub const THIRD_FLOOR_2: _bindgen_ty_7 = 14;
pub const THIRD_ROOF: _bindgen_ty_7 = 15;
pub const TOWER_BASE: _bindgen_ty_7 = 16;
pub const TOWER_FLOOR: _bindgen_ty_7 = 17;
pub const TOWER_PIECE: _bindgen_ty_7 = 18;
pub const TOWER_TOP: _bindgen_ty_7 = 19;
pub const END_CITY_PIECES_MAX: _bindgen_ty_7 = 421;
pub type _bindgen_ty_7 = ::std::os::raw::c_uint;
extern "C" {
    pub fn getFortressPieces(
        list: *mut Piece,
        n: ::std::os::raw::c_int,
        mc: ::std::os::raw::c_int,
        seed: u64,
        chunkX: ::std::os::raw::c_int,
        chunkZ: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
pub const FORTRESS_START: _bindgen_ty_8 = 0;
pub const BRIDGE_STRAIGHT: _bindgen_ty_8 = 1;
pub const BRIDGE_CROSSING: _bindgen_ty_8 = 2;
pub const BRIDGE_FORTIFIED_CROSSING: _bindgen_ty_8 = 3;
pub const BRIDGE_STAIRS: _bindgen_ty_8 = 4;
pub const BRIDGE_SPAWNER: _bindgen_ty_8 = 5;
pub const BRIDGE_CORRIDOR_ENTRANCE: _bindgen_ty_8 = 6;
pub const CORRIDOR_STRAIGHT: _bindgen_ty_8 = 7;
pub const CORRIDOR_CROSSING: _bindgen_ty_8 = 8;
pub const CORRIDOR_TURN_RIGHT: _bindgen_ty_8 = 9;
pub const CORRIDOR_TURN_LEFT: _bindgen_ty_8 = 10;
pub const CORRIDOR_STAIRS: _bindgen_ty_8 = 11;
pub const CORRIDOR_T_CROSSING: _bindgen_ty_8 = 12;
pub const CORRIDOR_NETHER_WART: _bindgen_ty_8 = 13;
pub const FORTRESS_END: _bindgen_ty_8 = 14;
pub const PIECE_COUNT: _bindgen_ty_8 = 15;
pub type _bindgen_ty_8 = ::std::os::raw::c_uint;
extern "C" {
    pub fn getFixedEndGateways(pos: *mut [Pos; 2usize], seed: u64);
}
pub const HouseSmall: _bindgen_ty_9 = 0;
pub const Church: _bindgen_ty_9 = 1;
pub const Library: _bindgen_ty_9 = 2;
pub const WoodHut: _bindgen_ty_9 = 3;
pub const Butcher: _bindgen_ty_9 = 4;
pub const FarmLarge: _bindgen_ty_9 = 5;
pub const FarmSmall: _bindgen_ty_9 = 6;
pub const Blacksmith: _bindgen_ty_9 = 7;
pub const HouseLarge: _bindgen_ty_9 = 8;
pub const HOUSE_NUM: _bindgen_ty_9 = 9;
pub type _bindgen_ty_9 = ::std::os::raw::c_uint;
extern "C" {
    pub fn getHouseList(
        houses: *mut ::std::os::raw::c_int,
        seed: u64,
        chunkX: ::std::os::raw::c_int,
        chunkZ: ::std::os::raw::c_int,
    ) -> u64;
}
extern "C" {
    pub fn monteCarloBiomes(
        g: *mut Generator,
        r: Range,
        rng: *mut u64,
        coverage: f64,
        confidence: f64,
        eval: ::std::option::Option<
            unsafe extern "C" fn(
                g: *mut Generator,
                scale: ::std::os::raw::c_int,
                x: ::std::os::raw::c_int,
                y: ::std::os::raw::c_int,
                z: ::std::os::raw::c_int,
                data: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setupBiomeFilter(
        bf: *mut BiomeFilter,
        mc: ::std::os::raw::c_int,
        flags: u32,
        required: *const ::std::os::raw::c_int,
        requiredLen: ::std::os::raw::c_int,
        excluded: *const ::std::os::raw::c_int,
        excludedLen: ::std::os::raw::c_int,
        matchany: *const ::std::os::raw::c_int,
        matchanyLen: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn checkForBiomes(
        g: *mut Generator,
        cache: *mut ::std::os::raw::c_int,
        r: Range,
        dim: ::std::os::raw::c_int,
        seed: u64,
        filter: *const BiomeFilter,
        stop: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn checkForBiomesAtLayer(
        ls: *mut LayerStack,
        entry: *mut Layer,
        cache: *mut ::std::os::raw::c_int,
        seed: u64,
        x: ::std::os::raw::c_int,
        z: ::std::os::raw::c_int,
        w: ::std::os::raw::c_uint,
        h: ::std::os::raw::c_uint,
        filter: *const BiomeFilter,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn checkForTemps(
        g: *mut LayerStack,
        seed: u64,
        x: ::std::os::raw::c_int,
        z: ::std::os::raw::c_int,
        w: ::std::os::raw::c_int,
        h: ::std::os::raw::c_int,
        tc: *const ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getBiomeCenters(
        pos: *mut Pos,
        siz: *mut ::std::os::raw::c_int,
        nmax: ::std::os::raw::c_int,
        g: *mut Generator,
        r: Range,
        match_: ::std::os::raw::c_int,
        minsiz: ::std::os::raw::c_int,
        tol: ::std::os::raw::c_int,
        stop: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn canBiomeGenerate(
        layerId: ::std::os::raw::c_int,
        mc: ::std::os::raw::c_int,
        flags: u32,
        biomeID: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn genPotential(
        mL: *mut u64,
        mM: *mut u64,
        layerId: ::std::os::raw::c_int,
        mc: ::std::os::raw::c_int,
        flags: u32,
        biomeID: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn getAvailableBiomes(
        mL: *mut u64,
        mM: *mut u64,
        layerId: ::std::os::raw::c_int,
        mc: ::std::os::raw::c_int,
        flags: u32,
    );
}
extern "C" {
    #[doc = " Runs a gradient descent towards the minimum of the noise parameter times a\n given factor. The algorithm is restricted to the area (x,z,w,h) and starts\n at (i0,j0) relative to (x,z). The iteration is terminated when either\n 1) a fix point has been reached,\n 2) maxiter iterations have been completed,\n 3) or the sampling position has moved more than maxrad away from (i0,j0).\n\n Alpha is an optimization argument that is used to determine the length of\n large steps based on the current gradient.\n\n Optionally, the iteration can also call the custom function:\n  func(data, x, z, factor*para_noise(x,z));\n\n The return value is the minimum value reached."]
    pub fn getParaDescent(
        para: *const DoublePerlinNoise,
        factor: f64,
        x: ::std::os::raw::c_int,
        z: ::std::os::raw::c_int,
        w: ::std::os::raw::c_int,
        h: ::std::os::raw::c_int,
        i0: ::std::os::raw::c_int,
        j0: ::std::os::raw::c_int,
        maxrad: ::std::os::raw::c_int,
        maxiter: ::std::os::raw::c_int,
        alpha: f64,
        data: *mut ::std::os::raw::c_void,
        func: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: ::std::os::raw::c_int,
                arg3: ::std::os::raw::c_int,
                arg4: f64,
            ) -> ::std::os::raw::c_int,
        >,
    ) -> f64;
}
extern "C" {
    #[doc = " Determines the value range of a climate noise parameter over the given area.\n The sampling has scale 1:4 and sampling shift is not considered, so biomes\n could potentially *leak* in at the boarders.\n An optional function:\n  func(data, x, z, climate_noise(x,z))\n is called in each gradient descent iteration. If this function returns\n non-zero the search is aborted, the results are undefined and a non-zero\n error is returned.\n\n The results are written to pmin and pmax (which would be cast to an integer\n during boime mapping). Nullable, to look for minima and maxima separately."]
    pub fn getParaRange(
        para: *const DoublePerlinNoise,
        pmin: *mut f64,
        pmax: *mut f64,
        x: ::std::os::raw::c_int,
        z: ::std::os::raw::c_int,
        w: ::std::os::raw::c_int,
        h: ::std::os::raw::c_int,
        data: *mut ::std::os::raw::c_void,
        func: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: ::std::os::raw::c_int,
                arg3: ::std::os::raw::c_int,
                arg4: f64,
            ) -> ::std::os::raw::c_int,
        >,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Gets the min/max parameter values within which a biome change can occur."]
    pub fn getBiomeParaExtremes(mc: ::std::os::raw::c_int) -> *const ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Gets the min/max possible noise parameter values at which the given biome\n can generate. The values are in min/max pairs in order of:\n temperature, humidity, continentalness, erosion, depth, weirdness."]
    pub fn getBiomeParaLimits(
        mc: ::std::os::raw::c_int,
        id: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Determines which biomes are able to generate given a set of climate\n parameter limits. Possible biomes are marked non-zero in the 'ids'."]
    pub fn getPossibleBiomesForLimits(
        ids: *mut ::std::os::raw::c_char,
        mc: ::std::os::raw::c_int,
        limits: *mut [::std::os::raw::c_int; 2usize],
    );
}
extern "C" {
    #[doc = " Find the largest rectangle in ids[sx][sz] which consists only of 'match'.\n The limit corners are written to p0 and p1. Returned is the rectangle's area."]
    pub fn getLargestRec(
        match_: ::std::os::raw::c_int,
        ids: *const ::std::os::raw::c_int,
        sx: ::std::os::raw::c_int,
        sz: ::std::os::raw::c_int,
        p0: *mut Pos,
        p1: *mut Pos,
    ) -> ::std::os::raw::c_int;
}
pub type __gnuc_va_list = __builtin_va_list;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __mbstate_t {
    pub __count: ::std::os::raw::c_int,
    pub __value: __mbstate_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t__bindgen_ty_1 {
    pub __wch: ::std::os::raw::c_uint,
    pub __wchb: [::std::os::raw::c_char; 4usize],
}
#[test]
fn bindgen_test_layout___mbstate_t__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<__mbstate_t__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(__mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(__mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wch) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t__bindgen_ty_1),
            "::",
            stringify!(__wch)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wchb) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t__bindgen_ty_1),
            "::",
            stringify!(__wchb)
        )
    );
}
impl Default for __mbstate_t__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout___mbstate_t() {
    const UNINIT: ::std::mem::MaybeUninit<__mbstate_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t>(),
        8usize,
        concat!("Size of: ", stringify!(__mbstate_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__mbstate_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__count) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__value) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__value)
        )
    );
}
impl Default for __mbstate_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos_t {
    pub __pos: __off_t,
    pub __state: __mbstate_t,
}
#[test]
fn bindgen_test_layout__G_fpos_t() {
    const UNINIT: ::std::mem::MaybeUninit<_G_fpos_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_G_fpos_t>(),
        16usize,
        concat!("Size of: ", stringify!(_G_fpos_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_G_fpos_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_G_fpos_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pos) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos_t),
            "::",
            stringify!(__pos)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__state) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos_t),
            "::",
            stringify!(__state)
        )
    );
}
impl Default for _G_fpos_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type __fpos_t = _G_fpos_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos64_t {
    pub __pos: __off64_t,
    pub __state: __mbstate_t,
}
#[test]
fn bindgen_test_layout__G_fpos64_t() {
    const UNINIT: ::std::mem::MaybeUninit<_G_fpos64_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_G_fpos64_t>(),
        16usize,
        concat!("Size of: ", stringify!(_G_fpos64_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_G_fpos64_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_G_fpos64_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pos) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos64_t),
            "::",
            stringify!(__pos)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__state) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos64_t),
            "::",
            stringify!(__state)
        )
    );
}
impl Default for _G_fpos64_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type __fpos64_t = _G_fpos64_t;
pub type __FILE = _IO_FILE;
pub type FILE = _IO_FILE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_marker {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_codecvt {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_wide_data {
    _unused: [u8; 0],
}
pub type _IO_lock_t = ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _IO_FILE {
    pub _flags: ::std::os::raw::c_int,
    pub _IO_read_ptr: *mut ::std::os::raw::c_char,
    pub _IO_read_end: *mut ::std::os::raw::c_char,
    pub _IO_read_base: *mut ::std::os::raw::c_char,
    pub _IO_write_base: *mut ::std::os::raw::c_char,
    pub _IO_write_ptr: *mut ::std::os::raw::c_char,
    pub _IO_write_end: *mut ::std::os::raw::c_char,
    pub _IO_buf_base: *mut ::std::os::raw::c_char,
    pub _IO_buf_end: *mut ::std::os::raw::c_char,
    pub _IO_save_base: *mut ::std::os::raw::c_char,
    pub _IO_backup_base: *mut ::std::os::raw::c_char,
    pub _IO_save_end: *mut ::std::os::raw::c_char,
    pub _markers: *mut _IO_marker,
    pub _chain: *mut _IO_FILE,
    pub _fileno: ::std::os::raw::c_int,
    pub _flags2: ::std::os::raw::c_int,
    pub _old_offset: __off_t,
    pub _cur_column: ::std::os::raw::c_ushort,
    pub _vtable_offset: ::std::os::raw::c_schar,
    pub _shortbuf: [::std::os::raw::c_char; 1usize],
    pub _lock: *mut _IO_lock_t,
    pub _offset: __off64_t,
    pub _codecvt: *mut _IO_codecvt,
    pub _wide_data: *mut _IO_wide_data,
    pub _freeres_list: *mut _IO_FILE,
    pub _freeres_buf: *mut ::std::os::raw::c_void,
    pub __pad5: usize,
    pub _mode: ::std::os::raw::c_int,
    pub _unused2: [::std::os::raw::c_char; 20usize],
}
#[test]
fn bindgen_test_layout__IO_FILE() {
    const UNINIT: ::std::mem::MaybeUninit<_IO_FILE> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_IO_FILE>(),
        216usize,
        concat!("Size of: ", stringify!(_IO_FILE))
    );
    assert_eq!(
        ::std::mem::align_of::<_IO_FILE>(),
        8usize,
        concat!("Alignment of ", stringify!(_IO_FILE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_read_ptr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_read_end) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_end)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_read_base) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_write_base) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_write_ptr) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_write_end) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_end)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_buf_base) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_buf_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_buf_end) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_buf_end)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_save_base) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_save_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_backup_base) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_backup_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_save_end) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_save_end)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._markers) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_markers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._chain) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_chain)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._fileno) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_fileno)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._flags2) as usize - ptr as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_flags2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._old_offset) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_old_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._cur_column) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_cur_column)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._vtable_offset) as usize - ptr as usize },
        130usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_vtable_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._shortbuf) as usize - ptr as usize },
        131usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_shortbuf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._lock) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_lock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._offset) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._codecvt) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_codecvt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._wide_data) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_wide_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._freeres_list) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_freeres_list)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._freeres_buf) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_freeres_buf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad5) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(__pad5)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._mode) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_mode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._unused2) as usize - ptr as usize },
        196usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_unused2)
        )
    );
}
impl Default for _IO_FILE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type cookie_read_function_t = ::std::option::Option<
    unsafe extern "C" fn(
        __cookie: *mut ::std::os::raw::c_void,
        __buf: *mut ::std::os::raw::c_char,
        __nbytes: usize,
    ) -> __ssize_t,
>;
pub type cookie_write_function_t = ::std::option::Option<
    unsafe extern "C" fn(
        __cookie: *mut ::std::os::raw::c_void,
        __buf: *const ::std::os::raw::c_char,
        __nbytes: usize,
    ) -> __ssize_t,
>;
pub type cookie_seek_function_t = ::std::option::Option<
    unsafe extern "C" fn(
        __cookie: *mut ::std::os::raw::c_void,
        __pos: *mut __off64_t,
        __w: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
pub type cookie_close_function_t = ::std::option::Option<
    unsafe extern "C" fn(__cookie: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
>;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _IO_cookie_io_functions_t {
    pub read: cookie_read_function_t,
    pub write: cookie_write_function_t,
    pub seek: cookie_seek_function_t,
    pub close: cookie_close_function_t,
}
#[test]
fn bindgen_test_layout__IO_cookie_io_functions_t() {
    const UNINIT: ::std::mem::MaybeUninit<_IO_cookie_io_functions_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_IO_cookie_io_functions_t>(),
        32usize,
        concat!("Size of: ", stringify!(_IO_cookie_io_functions_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_IO_cookie_io_functions_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_IO_cookie_io_functions_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).read) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_cookie_io_functions_t),
            "::",
            stringify!(read)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).write) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_cookie_io_functions_t),
            "::",
            stringify!(write)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).seek) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_cookie_io_functions_t),
            "::",
            stringify!(seek)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).close) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_cookie_io_functions_t),
            "::",
            stringify!(close)
        )
    );
}
pub type cookie_io_functions_t = _IO_cookie_io_functions_t;
pub type va_list = __gnuc_va_list;
pub type fpos_t = __fpos_t;
extern "C" {
    pub static mut stdin: *mut FILE;
}
extern "C" {
    pub static mut stdout: *mut FILE;
}
extern "C" {
    pub static mut stderr: *mut FILE;
}
extern "C" {
    pub fn remove(__filename: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rename(
        __old: *const ::std::os::raw::c_char,
        __new: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn renameat(
        __oldfd: ::std::os::raw::c_int,
        __old: *const ::std::os::raw::c_char,
        __newfd: ::std::os::raw::c_int,
        __new: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tmpfile() -> *mut FILE;
}
extern "C" {
    pub fn tmpnam(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tmpnam_r(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tempnam(
        __dir: *const ::std::os::raw::c_char,
        __pfx: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fflush(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fflush_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fopen(
        __filename: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn freopen(
        __filename: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
        __stream: *mut FILE,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fdopen(__fd: ::std::os::raw::c_int, __modes: *const ::std::os::raw::c_char)
        -> *mut FILE;
}
extern "C" {
    pub fn fopencookie(
        __magic_cookie: *mut ::std::os::raw::c_void,
        __modes: *const ::std::os::raw::c_char,
        __io_funcs: cookie_io_functions_t,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fmemopen(
        __s: *mut ::std::os::raw::c_void,
        __len: usize,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn open_memstream(
        __bufloc: *mut *mut ::std::os::raw::c_char,
        __sizeloc: *mut usize,
    ) -> *mut FILE;
}
extern "C" {
    pub fn setbuf(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn setvbuf(
        __stream: *mut FILE,
        __buf: *mut ::std::os::raw::c_char,
        __modes: ::std::os::raw::c_int,
        __n: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setbuffer(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char, __size: usize);
}
extern "C" {
    pub fn setlinebuf(__stream: *mut FILE);
}
extern "C" {
    pub fn fprintf(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn printf(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sprintf(
        __s: *mut ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfprintf(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vprintf(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsprintf(
        __s: *mut ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn snprintf(
        __s: *mut ::std::os::raw::c_char,
        __maxlen: ::std::os::raw::c_ulong,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsnprintf(
        __s: *mut ::std::os::raw::c_char,
        __maxlen: ::std::os::raw::c_ulong,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vasprintf(
        __ptr: *mut *mut ::std::os::raw::c_char,
        __f: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __asprintf(
        __ptr: *mut *mut ::std::os::raw::c_char,
        __fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn asprintf(
        __ptr: *mut *mut ::std::os::raw::c_char,
        __fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vdprintf(
        __fd: ::std::os::raw::c_int,
        __fmt: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dprintf(
        __fd: ::std::os::raw::c_int,
        __fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fscanf(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scanf(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sscanf(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_fscanf"]
    pub fn fscanf1(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_scanf"]
    pub fn scanf1(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_sscanf"]
    pub fn sscanf1(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfscanf(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vscanf(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsscanf(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vfscanf"]
    pub fn vfscanf1(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vscanf"]
    pub fn vscanf1(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vsscanf"]
    pub fn vsscanf1(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getc(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar_unlocked() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar_unlocked(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getw(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putw(__w: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgets(
        __s: *mut ::std::os::raw::c_char,
        __n: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __getdelim(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut usize,
        __delimiter: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn getdelim(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut usize,
        __delimiter: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn getline(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut usize,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn fputs(__s: *const ::std::os::raw::c_char, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn puts(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ungetc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fread(
        __ptr: *mut ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
        __n: ::std::os::raw::c_ulong,
        __stream: *mut FILE,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn fwrite(
        __ptr: *const ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
        __n: ::std::os::raw::c_ulong,
        __s: *mut FILE,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn fread_unlocked(
        __ptr: *mut ::std::os::raw::c_void,
        __size: usize,
        __n: usize,
        __stream: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn fwrite_unlocked(
        __ptr: *const ::std::os::raw::c_void,
        __size: usize,
        __n: usize,
        __stream: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn fseek(
        __stream: *mut FILE,
        __off: ::std::os::raw::c_long,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftell(__stream: *mut FILE) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn rewind(__stream: *mut FILE);
}
extern "C" {
    pub fn fseeko(
        __stream: *mut FILE,
        __off: __off_t,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftello(__stream: *mut FILE) -> __off_t;
}
extern "C" {
    pub fn fgetpos(__stream: *mut FILE, __pos: *mut fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fsetpos(__stream: *mut FILE, __pos: *const fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearerr(__stream: *mut FILE);
}
extern "C" {
    pub fn feof(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearerr_unlocked(__stream: *mut FILE);
}
extern "C" {
    pub fn feof_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn perror(__s: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn fileno(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fileno_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn popen(
        __command: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn ctermid(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn flockfile(__stream: *mut FILE);
}
extern "C" {
    pub fn ftrylockfile(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn funlockfile(__stream: *mut FILE);
}
extern "C" {
    pub fn __uflow(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __overflow(arg1: *mut FILE, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Quad-Witch-Huts\n\n  For a quad-structure, we mainly care about relative positioning, so we can\n  get away with just checking the regions near the origin: (0,0),(0,1),(1,0)\n  and (1,1) and then move the structures to the desired position.\n\n  Futhermore, the PRNG that determines the chunk positions inside each region,\n  performs some modular arithmatic on the 48-bit numbers which causes some\n  restrictions on the lower bits when looking for near perfect structure\n  positions. This is difficult to prove, but can be used to reduce the number\n  of free bits to 28 which can be comfortably brute-forced to get the entire\n  set of quad-structure candidates. Each of the seeds found this way\n  describes entire set of possible quad-witch-huts (with degrees of freedom\n  for region-transposition, as well as the top 16-bit bits)."]
    pub static low20QuadIdeal: [u64; 4usize];
}
extern "C" {
    pub static low20QuadClassic: [u64; 5usize];
}
extern "C" {
    pub static low20QuadHutNormal: [u64; 11usize];
}
extern "C" {
    pub static low20QuadHutBarely: [u64; 29usize];
}
pub const CST_NONE: _bindgen_ty_10 = 0;
pub const CST_IDEAL: _bindgen_ty_10 = 1;
pub const CST_CLASSIC: _bindgen_ty_10 = 2;
pub const CST_NORMAL: _bindgen_ty_10 = 3;
pub const CST_BARELY: _bindgen_ty_10 = 4;
pub type _bindgen_ty_10 = ::std::os::raw::c_uint;
extern "C" {
    pub fn getQuadHutCst(low20: u64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn searchAll48(
        seedbuf: *mut *mut u64,
        buflen: *mut u64,
        path: *const ::std::os::raw::c_char,
        threads: ::std::os::raw::c_int,
        lowBits: *const u64,
        lowBitN: ::std::os::raw::c_int,
        check: ::std::option::Option<
            unsafe extern "C" fn(
                s48: u64,
                data: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        data: *mut ::std::os::raw::c_void,
        stop: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getOptimalAfk(
        p: *mut Pos,
        ax: ::std::os::raw::c_int,
        ay: ::std::os::raw::c_int,
        az: ::std::os::raw::c_int,
        spcnt: *mut ::std::os::raw::c_int,
    ) -> Pos;
}
extern "C" {
    pub fn scanForQuads(
        sconf: StructureConfig,
        radius: ::std::os::raw::c_int,
        s48: u64,
        lowBits: *const u64,
        lowBitN: ::std::os::raw::c_int,
        salt: u64,
        x: ::std::os::raw::c_int,
        z: ::std::os::raw::c_int,
        w: ::std::os::raw::c_int,
        h: ::std::os::raw::c_int,
        qplist: *mut Pos,
        n: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn loadSavedSeeds(fnam: *const ::std::os::raw::c_char, scnt: *mut u64) -> *mut u64;
}
extern "C" {
    #[doc = " convert between version enum and text"]
    pub fn mc2str(mc: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn str2mc(s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " get the resource id name for a biome (for versions 1.13+)"]
    pub fn biome2str(
        mc: ::std::os::raw::c_int,
        id: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " get the resource id name for a structure"]
    pub fn struct2str(stype: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " initialize a biome colormap with some defaults"]
    pub fn initBiomeColors(biomeColors: *mut [::std::os::raw::c_uchar; 3usize]);
}
extern "C" {
    pub fn initBiomeTypeColors(biomeColors: *mut [::std::os::raw::c_uchar; 3usize]);
}
extern "C" {
    pub fn parseBiomeColors(
        biomeColors: *mut [::std::os::raw::c_uchar; 3usize],
        buf: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn biomesToImage(
        pixels: *mut ::std::os::raw::c_uchar,
        biomeColors: *mut [::std::os::raw::c_uchar; 3usize],
        biomes: *const ::std::os::raw::c_int,
        sx: ::std::os::raw::c_uint,
        sy: ::std::os::raw::c_uint,
        pixscale: ::std::os::raw::c_uint,
        flip: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn savePPM(
        path: *const ::std::os::raw::c_char,
        pixels: *const ::std::os::raw::c_uchar,
        sx: ::std::os::raw::c_uint,
        sy: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    const UNINIT: ::std::mem::MaybeUninit<__va_list_tag> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__va_list_tag>(),
        24usize,
        concat!("Size of: ", stringify!(__va_list_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<__va_list_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__va_list_tag))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gp_offset) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(gp_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fp_offset) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(fp_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).overflow_arg_area) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(overflow_arg_area)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reg_save_area) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(reg_save_area)
        )
    );
}
impl Default for __va_list_tag {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
